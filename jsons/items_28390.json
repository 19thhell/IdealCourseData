[{"detail": [{"content": "NYU &gt;   ITS   &gt; Communicate &amp; Collaborate   &gt; NYU Google Apps                                                                                        Skip to Navigation | Skip to Content                                        Service Status | News | ServiceLink | IT Service Desk                         Quick Links         Academic Calendars      Albert      Athletics      Bookstores      Career Development      Giving to NYU      Health Center      Housing      ITS      Job Listings      Libraries      NYU Apparel      NYU Facts      Public Affairs      Public Safety      Registrar      Student Resource Center      Wellness Exchange      NYU A-Z              Schools         Arts and Science      College of Arts and Science      College of Dentistry      College of Nursing      Courant Institute of Mathematical Sciences      Gallatin School of Individualized Study      Graduate School of Arts and Science      Institute of Fine Arts      Institute for the Study of the Ancient World         Leonard N. Stern School of Business      Liberal Studies Program      NYU Abu Dhabi      NYU Shanghai      Polytechnic School of Engineering      Robert F. Wagner Graduate School of Public Service      School of Continuing and Professional Studies      School of Law      School of Medicine      Silver School of Social Work      Steinhardt School of Culture, Education, and Human Development      Tisch School of the Arts                                                        go                                                    New York University              New York University              Information Technology Services                                                 About ITS                              Get Connected                                Communicate & Collaborate                             Computer Labs                          E-mail Direct                          File Storage & Sharing                          NYUHome                          NYU Classes                          NYU Blogs                              NYU Calendar                          NYU Chat/Hangouts                          NYU Drive                          NYU Email                         NYU Google Apps                               NYU Groups                          NYU Lists                          NYU Directory                          NYU Sites                          NYU Stream                          NYU Wikis                          Peer-to-Peer File Sharing                         NYU Print Service                          Telephones &amp; Voice Mail                          Video Conferencing                          Virtual Computer Lab                          Web Publishing                                           Help & Support                                 Computer Security                               Instruction & Research                               Locations & Facilities                                                                         Home           //        Communicate &amp; Collaborate                 //         NYU Google Apps                                            NYU Google Apps for Education                                                  search the site                                                                        IT Service Desk      24 hours, 7 days a week     Email: AskITS@nyu.edu     In NYC: 1-212-998-3333      Additional contact info &raquo;      NYU ServiceLink &raquo;     related pages             NYU Email & Calendar setup instructions for mobile devices and desktop applications       Terms of Use for NYU Google Apps for Education         Guidance for Privacy and Security in NYU Google Apps for Education       Q&A Regarding Google's March 1, 2012 Privacy Policy           helpful links            Google Help & Support      Google Apps Learning Center      Google Apps for Admins Forum      Google in Education - Instructors      Google in Education - Students                         Feed Widget                NYU Google Apps is a set of online communication and collaboration applications offered to eligible members of the NYU community to facilitate teaching and learning, research, and administrative functions of the University. NYU Google Apps can be divided into two groups:       Core Apps , which include:     NYU Email and Contacts   NYU Calendar   NYU Drive   NYU Groups   NYU Sites   NYU Chat/Hangouts, including group video calls     Commercial Apps , which include all other Google services, such as Google+, YouTube, Picassa, Google Reader, Blogger, etc.     The Core Apps are covered by a special agreement between NYU and Google, so NYU community members will not see advertisements and the information present in the Core Apps is private. The Core Apps are sufficiently secure to be used for private documents, such as tenure committee discussions, personal papers, class notes, and scholarly materials. It is especially easy to use NYU Google Apps to share documents and files with others; therefore, special care should be taken to ensure that you do not share documents more broadly than you intend.    Restricted and research data have specific security requirements for storage systems and should not be stored or transmitted through NYU Google Apps. See NYU's Data Classification Policy for details. ITS has published the Guidance for Privacy and Security in NYU Google Apps for Education to help NYU community members better manage sensitive data in NYU Google Apps.    Those who choose to use the Commercial Apps offered by Google should be aware that the information stored in a Commercial App may be subject to data mining and that they may see advertisements. See the Commercial Apps tab of this site for important information about the difference between Core and Commercial Google Apps.    See the individual core apps links in the first paragraph, above, or the left navigation menu for additional information about each Core App.    Eligibility   Admitted and enrolled degree students, current and retired employees, alumni, and sponsored affiliates are eligible for these services.    Additional Support   Should you have any questions or concerns, please search the knowledge base within NYU ServiceLink , contact the IT Service Desk via  email at AskITS@nyu.edu or, in New York, by calling 212-998-3333. For global locations, check the IT Service Desk page for local service desk information."}]},
{"detail": [{"content": "NYU &gt;   ITS   &gt; Communicate &amp; Collaborate   &gt; NYU Google Apps                                                                                        Skip to Navigation | Skip to Content                                        Service Status | News | ServiceLink | IT Service Desk                         Quick Links         Academic Calendars      Albert      Athletics      Bookstores      Career Development      Giving to NYU      Health Center      Housing      ITS      Job Listings      Libraries      NYU Apparel      NYU Facts      Public Affairs      Public Safety      Registrar      Student Resource Center      Wellness Exchange      NYU A-Z              Schools         Arts and Science      College of Arts and Science      College of Dentistry      College of Nursing      Courant Institute of Mathematical Sciences      Gallatin School of Individualized Study      Graduate School of Arts and Science      Institute of Fine Arts      Institute for the Study of the Ancient World         Leonard N. Stern School of Business      Liberal Studies Program      NYU Abu Dhabi      NYU Shanghai      Polytechnic School of Engineering      Robert F. Wagner Graduate School of Public Service      School of Continuing and Professional Studies      School of Law      School of Medicine      Silver School of Social Work      Steinhardt School of Culture, Education, and Human Development      Tisch School of the Arts                                                        go                                                    New York University              New York University              Information Technology Services                                                 About ITS                              Get Connected                                Communicate & Collaborate                             Computer Labs                          E-mail Direct                          File Storage & Sharing                          NYUHome                          NYU Classes                          NYU Blogs                              NYU Calendar                          NYU Chat/Hangouts                          NYU Drive                          NYU Email                         NYU Google Apps                               NYU Groups                          NYU Lists                          NYU Directory                          NYU Sites                          NYU Stream                          NYU Wikis                          Peer-to-Peer File Sharing                         NYU Print Service                          Telephones &amp; Voice Mail                          Video Conferencing                          Virtual Computer Lab                          Web Publishing                                           Help & Support                                 Computer Security                               Instruction & Research                               Locations & Facilities                                                                         Home           //        Communicate &amp; Collaborate                 //         NYU Google Apps                                            NYU Google Apps for Education                                                  search the site                                                                        IT Service Desk      24 hours, 7 days a week     Email: AskITS@nyu.edu     In NYC: 1-212-998-3333      Additional contact info &raquo;      NYU ServiceLink &raquo;     related pages             NYU Email & Calendar setup instructions for mobile devices and desktop applications       Terms of Use for NYU Google Apps for Education         Guidance for Privacy and Security in NYU Google Apps for Education       Q&A Regarding Google's March 1, 2012 Privacy Policy           helpful links            Google Help & Support      Google Apps Learning Center      Google Apps for Admins Forum      Google in Education - Instructors      Google in Education - Students                         Feed Widget                NYU Google Apps is a set of online communication and collaboration applications offered to eligible members of the NYU community to facilitate teaching and learning, research, and administrative functions of the University. NYU Google Apps can be divided into two groups:       Core Apps , which include:     NYU Email and Contacts   NYU Calendar   NYU Drive   NYU Groups   NYU Sites   NYU Chat/Hangouts, including group video calls     Commercial Apps , which include all other Google services, such as Google+, YouTube, Picassa, Google Reader, Blogger, etc.     The Core Apps are covered by a special agreement between NYU and Google, so NYU community members will not see advertisements and the information present in the Core Apps is private. The Core Apps are sufficiently secure to be used for private documents, such as tenure committee discussions, personal papers, class notes, and scholarly materials. It is especially easy to use NYU Google Apps to share documents and files with others; therefore, special care should be taken to ensure that you do not share documents more broadly than you intend.    Restricted and research data have specific security requirements for storage systems and should not be stored or transmitted through NYU Google Apps. See NYU's Data Classification Policy for details. ITS has published the Guidance for Privacy and Security in NYU Google Apps for Education to help NYU community members better manage sensitive data in NYU Google Apps.    Those who choose to use the Commercial Apps offered by Google should be aware that the information stored in a Commercial App may be subject to data mining and that they may see advertisements. See the Commercial Apps tab of this site for important information about the difference between Core and Commercial Google Apps.    See the individual core apps links in the first paragraph, above, or the left navigation menu for additional information about each Core App.    Eligibility   Admitted and enrolled degree students, current and retired employees, alumni, and sponsored affiliates are eligible for these services.    Additional Support   Should you have any questions or concerns, please search the knowledge base within NYU ServiceLink , contact the IT Service Desk via  email at AskITS@nyu.edu or, in New York, by calling 212-998-3333. For global locations, check the IT Service Desk page for local service desk information."}, {"content": "Synchronous Serial Communication: The Basics | ITP Physical Computing                                                          ITP Physical Computing             Search                  Primary Menu       Skip to content       Syllabus Phys-comp List Topics What Is Physical Computing? Electronics Electricity: the Basics Transistors, Relays, and Controlling High-Current Loads Understanding DC Power Supplies  Microcontrollers Microcontrollers: The Basics Digital Input &#038; Output Analog Input Analog Output  Programming Programming Terms and Programming Environments Variables  Sensors: the Basics Serial Communication Asynchronous Serial Communication: The Basics Interpreting Serial Data Synchronous Serial Communication: The Basics  DC Motors DC Motors: The Basics Controlling Stepper Motors  Videos Videos: Electricity Videos: Tools Videos: Schematic Diagrams Videos: Sensors Videos: Digital and Analog Input and Output Videos: Serial Communication Videos: Relays, Transistors, and Motors Videos: Prototyping Methods and Tips  Labs Labs: Electronics Lab: Components Lab: Setting Up A Breadboard Lab: Switches Lab: Soldering Lab: Electronics  Labs: Arduino Digital and Analog Lab: Digital Input and Output with an Arduino Lab: Analog In with an Arduino Lab: Servo Motor Control with an Arduino Lab: Tone Output Using An Arduino Lab: Sensor Change Detection  Labs: Serial Communication Lab: Serial Output from an Arduino Lab: Two-way (Duplex) Serial Communication using an Arduino Lab: MIDI Output using an Arduino Lab: Arduino to DAW Lab: Serial Communication with Node.js Lab: SPI Communication With A Digital Potentiometer Lab: I2C Communication With An Infrared Temperature Sensor  Labs: Motors and Transistors Lab: Using a Transistor to Control a High Current Load Lab: Using a Transistor to Control High Current Loads with an Arduino Lab: DC Motor Control Using an H-Bridge Lab: Controlling a Stepper Motor With an H-Bridge  Labs: Mouse Control Lab: Mouse Control Lab: Mouse Control With Pushbuttons Lab: Mouse Control With Joystick  Resources Books GitHub Repository Parts Needed for Physical Computing Additional Useful Parts and Tools Other Useful Sites Suppliers Checkout Components at ITP LittleBits Resources  Sections Tom Igoe Class Oct 1 Afternoon  Benedetta Piantella MONDAY WEDNESDAY  Jeff Feddersen Arlene Ducao                                        Search for:                                                            Synchronous Serial Communication: The Basics       Introduction Contents  1 Introduction  2 Serial Peripheral Interface (SPI)  3 Inter-Integrated Circuit (I2C) or Two-Wire Interface (TWI)  4 I2C Control of Multiple Microcontrollers  5 Conclusion    Related Video: Intro to Synchronous Serial   Asynchronous serial communication, which you can see in action in the Serial Output lab, is a common way for two computers to communicate. Both computers must have their own clock, and keep time independently of each other. This works well for personal computers, mobile devices, and microcontrollers because they all have their own clock crystal that acts as the processor&#8217;s heartbeat. However, there are simpler integrated circuits that have only one function, such as to read a sensor or to control a digital potentiometer or an oscillator to drive a PWM circuit. These ICs have no clock crystal of their own. They consist of a few memory registers and the minimal circuitry needed to connect these memory registers to the circuit that they control. To communicate with these ICs, you need to use synchronous serial communication.   To get the most out of these notes, you should know\u00a0 what a microcontroller is\u00a0 and have an understanding of the\u00a0 basics of microcontroller programming . You should also understand the\u00a0 basics of serial communication \u00a0as well.   Synchronous serial communication protocols feature a controller device which sends a clock pulse to one or more peripheral devices. The devices exchange a bit of data every time the clock changes. There are two common forms of synchronous serial, Inter-Integrated Circuit, or I2C (sometimes also called Two-Wire Interface, or TWI), and Serial Peripheral Interface, or SPI.   Synchronous serial devices communicate by shifting bits of data along their communication lines, like a bucket brigade. Data moved down the line one bit every time the clock pulses. All the devices in a synchronous serial chain share the same data and clock lines. Peripheral devices are directed by the controller device when to listen to the bits coming down the line, and when to ignore them. However, the two most common synchronous serial protocols, SPI and I2C, use different methods for directing the peripheral devices.   Serial Peripheral Interface (SPI)   Related Video: SPI     SPI devices are connected by four wires, as shown below:  a Serial Data In (SDI), on which the controller sends data to the peripheral devices. SDI is also sometimes referred to as Master Out, Slave In (MOSI) .   a Serial Data Out (SDO), on which the peripheral devices send data to the controller. SDO is also sometimes referred to as Master In, Slave Out (MISO)   a Clock \u00a0(SCLK) connection, on which the controller sends a regular clock signal to the peripheral devices.   one or more Chip Select (CS)\u00a0 connections, which the controller uses to signal the peripheral devices when to listen to incoming data and when to ignore it.     The SDI, SDO, and SCLK connections are shared between all the devices connected to the controller. This configuration is called a bus . Each peripheral has its own dedicated Chip Select connection to the controller, however.    A typical SPI bus configuration. The Controller&#8217;s output (MOSI) is the peripherals&#8217; input (SDI) and vice versa. Each peripheral gets its own Chip Select line. All other lines are shared.   When the controller device wants to communicate with one of the peripherals, it sets that device&#8217;s Chip Select pin low. The peripheral will then listen for new bits of data on the MOSI line every time the clock changes from low to high (called the rising edge of the clock). If it is instructed to send any data back, it will send data back to the controller when the clock signal changes from high to low (called the falling edge of the clock). When a peripheral device&#8217;s Chip Select pin is high, it will not respond to any commands sent on the SDI line.   The data exchange between SPI devices is usually shown like this:    A typical SPI data exchange. The Controller&#8217;s data (SDI or MOSI) are valid on the rising edge of the clock, while the Peripherals&#8217; data (SDO or MISO) are valid on the falling edge of the clock.   The Arduino&#8217;s SPI pins are determined by the processor. You can find the pins for the various models on the SPI library reference page . For the Arduino Uno, the pin numbers are pin 11 for MOSI, pin 12 for MISO, and pin 13 for Clock. Pin 10 is the default Chip Select pin, but you can use other pins for Chip Select as needed. The Arduino SPI library allows you to control the SPI bus. Most SPI devices that are compatible with Arduino come with their own libraries, however, which wrap the SPI library in commands specific to the device in question.   For example, the Analog Devices ADXL345 accelerometer can communicate via SPI. Its protocol works as follows: first the controller sets the ADXL345&#8217;s Chip Select pin low, then sends a command to the ADXL345 on the SDI (or MOSI) line to enter measurement mode. The ADXK345 then continually samples the accelerometer and stores the latest readings in three memory registers. When the controller wants to know those values, it sets the Chip Select pin low and sends a request to read those memory registers. The ADXL345 responds by sending back the contents of the memory registers on the SDO (MISO) line. When all the data has been received, the controller sets the Chip Select pin high again.   The advantage of SPI is that the data transactions are simple: all you need to do is to send the data to the device you&#8217;re communicating with. The disadvantage is that the number of wires needed to connect goes up by one for every peripheral device you add to the bus.    Data capture from a microcontroller communicating with an Analog Devices digital Potentiometer over SPI. The potentiometer sends no data, but the controller sends two bytes over the MOSI line.   Inter-Integrated Circuit (I2C) or Two-Wire Interface (TWI)   Related video: I2C   I2C is another popular synchronous serial protocol. It also uses a bus configuration like SPI, but there are only two connections between the controller device and the peripheral devices:     a Serial Clock (SCL) connection , on which the controller sends the clock signal, just as in SPI   a Serial Data (SDA) connection, on which the controller and peripherals exchange data in both directions.      I2C Bus diagram. Unlike the SPI diagram, only two connections are needed between controller and all the peripherals.   Each I2C peripheral device has a unique address on the bus. When the controller wants to communicate with a particular peripheral, it sends that peripheral&#8217;s address down the SDA connection, transferring each bit on the rising edge of the clock. An extra bit indicates whether the controller wants to write or read to the peripheral that it&#8217;s addressing. The appropriate peripheral then goes into listening mode, and the controller sends a command to the peripheral. Then the controller switches its connection to the SDA line from output to input. The peripheral then replies with the appropriate data, sending each bit on the falling edge of the clock. The controller switches its connection on the SDA line back to output once it&#8217;s received all of the data.   The I2C data capture below is typical (click to enlarge it). This is from a Texas Instruments TMP007 temperature sensor. The peripheral&#8217;s address is 0x40. First the controller sends a byte with 0x40 + 0 in the final bit, indicating that it plans to write a command to the peripheral. All of this data is sent valid on the rising edge of the clock. Then the controller sends a command, 0x03, which means &#8220;tell me your object&#8217;s\u00a0temperature&#8221; to this particular IC. Then the controller sends a byte with the peripheral&#8217;s\u00a0address again, 0x40 +1 in the final bit, indicating that it wants to read from the peripheral. The peripheral responds with two bytes, 0x0B and 0xC0. The controller then puts\u00a0those two bytes together to get the\u00a0object&#8217;s temperature (see the TMP007 datasheet if you want to know more)      The advantage of I2C is that you really only need two wires to connect all the I2C devices you want to your controller. The disadvantage is that you have to send an address before you send any command.   The Arduino&#8217;s I2C pins are determined by the processor. You can find the pins for the various models on the Wire\u00a0library reference page . The Arduino Wire library allows you to control the I2C bus. For the Arduino Uno, the pin numbers are analog pin 4 for SDA and analog pin 5 for SCL. On the Uno rev.3 layout, SDA and SCL are also broken out on the digital side of the board, next to the ground pin. \u00a0Most I2C devices that are compatible with Arduino come with their own libraries which wrap the Wire\u00a0library in commands specific to the device in question. For example, Adafruit&#8217;s library for the TMP007 relies on the Wire library to transmit and receive data.   I2C Control of Multiple Microcontrollers   You can also use I2C as a way to control many microcontrollers from one central controller. For example, if you needed to operate a large number of servomotors, you could put five or six each on a single Arduino, then chain several Arduinos together in an I2C chain and program them all to respond in slave mode . Then you would program a central controller in master mode , and have it send commands to the slave devices when it&#8217;s time to move each device&#8217;s servos. You can see an example of how to do this in this example from the Arduino site.   Conclusion   SPI and I2C are useful protocols because they allow you to interface with a wide variety of sensor and actuator ICs without having to use many of your microcontroller&#8217;s IO pins. Because they are both bus protocols, you can chain many devices on the same bus, and call on them only when needed from your microcontroller. For more on their usage, see the SPI Digital Potentiometer Lab and the I2C Contactless Temperature Sensor Lab.                                                 Proudly powered by WordPress"}]},
{"detail": [{"content": "NYU &gt;   ITS   &gt; Communicate &amp; Collaborate   &gt; NYU Google Apps                                                                                        Skip to Navigation | Skip to Content                                        Service Status | News | ServiceLink | IT Service Desk                         Quick Links         Academic Calendars      Albert      Athletics      Bookstores      Career Development      Giving to NYU      Health Center      Housing      ITS      Job Listings      Libraries      NYU Apparel      NYU Facts      Public Affairs      Public Safety      Registrar      Student Resource Center      Wellness Exchange      NYU A-Z              Schools         Arts and Science      College of Arts and Science      College of Dentistry      College of Nursing      Courant Institute of Mathematical Sciences      Gallatin School of Individualized Study      Graduate School of Arts and Science      Institute of Fine Arts      Institute for the Study of the Ancient World         Leonard N. Stern School of Business      Liberal Studies Program      NYU Abu Dhabi      NYU Shanghai      Polytechnic School of Engineering      Robert F. Wagner Graduate School of Public Service      School of Continuing and Professional Studies      School of Law      School of Medicine      Silver School of Social Work      Steinhardt School of Culture, Education, and Human Development      Tisch School of the Arts                                                        go                                                    New York University              New York University              Information Technology Services                                                 About ITS                              Get Connected                                Communicate & Collaborate                             Computer Labs                          E-mail Direct                          File Storage & Sharing                          NYUHome                          NYU Classes                          NYU Blogs                              NYU Calendar                          NYU Chat/Hangouts                          NYU Drive                          NYU Email                         NYU Google Apps                               NYU Groups                          NYU Lists                          NYU Directory                          NYU Sites                          NYU Stream                          NYU Wikis                          Peer-to-Peer File Sharing                         NYU Print Service                          Telephones &amp; Voice Mail                          Video Conferencing                          Virtual Computer Lab                          Web Publishing                                           Help & Support                                 Computer Security                               Instruction & Research                               Locations & Facilities                                                                         Home           //        Communicate &amp; Collaborate                 //         NYU Google Apps                                            NYU Google Apps for Education                                                  search the site                                                                        IT Service Desk      24 hours, 7 days a week     Email: AskITS@nyu.edu     In NYC: 1-212-998-3333      Additional contact info &raquo;      NYU ServiceLink &raquo;     related pages             NYU Email & Calendar setup instructions for mobile devices and desktop applications       Terms of Use for NYU Google Apps for Education         Guidance for Privacy and Security in NYU Google Apps for Education       Q&A Regarding Google's March 1, 2012 Privacy Policy           helpful links            Google Help & Support      Google Apps Learning Center      Google Apps for Admins Forum      Google in Education - Instructors      Google in Education - Students                         Feed Widget                NYU Google Apps is a set of online communication and collaboration applications offered to eligible members of the NYU community to facilitate teaching and learning, research, and administrative functions of the University. NYU Google Apps can be divided into two groups:       Core Apps , which include:     NYU Email and Contacts   NYU Calendar   NYU Drive   NYU Groups   NYU Sites   NYU Chat/Hangouts, including group video calls     Commercial Apps , which include all other Google services, such as Google+, YouTube, Picassa, Google Reader, Blogger, etc.     The Core Apps are covered by a special agreement between NYU and Google, so NYU community members will not see advertisements and the information present in the Core Apps is private. The Core Apps are sufficiently secure to be used for private documents, such as tenure committee discussions, personal papers, class notes, and scholarly materials. It is especially easy to use NYU Google Apps to share documents and files with others; therefore, special care should be taken to ensure that you do not share documents more broadly than you intend.    Restricted and research data have specific security requirements for storage systems and should not be stored or transmitted through NYU Google Apps. See NYU's Data Classification Policy for details. ITS has published the Guidance for Privacy and Security in NYU Google Apps for Education to help NYU community members better manage sensitive data in NYU Google Apps.    Those who choose to use the Commercial Apps offered by Google should be aware that the information stored in a Commercial App may be subject to data mining and that they may see advertisements. See the Commercial Apps tab of this site for important information about the difference between Core and Commercial Google Apps.    See the individual core apps links in the first paragraph, above, or the left navigation menu for additional information about each Core App.    Eligibility   Admitted and enrolled degree students, current and retired employees, alumni, and sponsored affiliates are eligible for these services.    Additional Support   Should you have any questions or concerns, please search the knowledge base within NYU ServiceLink , contact the IT Service Desk via  email at AskITS@nyu.edu or, in New York, by calling 212-998-3333. For global locations, check the IT Service Desk page for local service desk information."}, {"content": "Synchronous Serial Communication: The Basics | ITP Physical Computing                                                          ITP Physical Computing             Search                  Primary Menu       Skip to content       Syllabus Phys-comp List Topics What Is Physical Computing? Electronics Electricity: the Basics Transistors, Relays, and Controlling High-Current Loads Understanding DC Power Supplies  Microcontrollers Microcontrollers: The Basics Digital Input &#038; Output Analog Input Analog Output  Programming Programming Terms and Programming Environments Variables  Sensors: the Basics Serial Communication Asynchronous Serial Communication: The Basics Interpreting Serial Data Synchronous Serial Communication: The Basics  DC Motors DC Motors: The Basics Controlling Stepper Motors  Videos Videos: Electricity Videos: Tools Videos: Schematic Diagrams Videos: Sensors Videos: Digital and Analog Input and Output Videos: Serial Communication Videos: Relays, Transistors, and Motors Videos: Prototyping Methods and Tips  Labs Labs: Electronics Lab: Components Lab: Setting Up A Breadboard Lab: Switches Lab: Soldering Lab: Electronics  Labs: Arduino Digital and Analog Lab: Digital Input and Output with an Arduino Lab: Analog In with an Arduino Lab: Servo Motor Control with an Arduino Lab: Tone Output Using An Arduino Lab: Sensor Change Detection  Labs: Serial Communication Lab: Serial Output from an Arduino Lab: Two-way (Duplex) Serial Communication using an Arduino Lab: MIDI Output using an Arduino Lab: Arduino to DAW Lab: Serial Communication with Node.js Lab: SPI Communication With A Digital Potentiometer Lab: I2C Communication With An Infrared Temperature Sensor  Labs: Motors and Transistors Lab: Using a Transistor to Control a High Current Load Lab: Using a Transistor to Control High Current Loads with an Arduino Lab: DC Motor Control Using an H-Bridge Lab: Controlling a Stepper Motor With an H-Bridge  Labs: Mouse Control Lab: Mouse Control Lab: Mouse Control With Pushbuttons Lab: Mouse Control With Joystick  Resources Books GitHub Repository Parts Needed for Physical Computing Additional Useful Parts and Tools Other Useful Sites Suppliers Checkout Components at ITP LittleBits Resources  Sections Tom Igoe Class Oct 1 Afternoon  Benedetta Piantella MONDAY WEDNESDAY  Jeff Feddersen Arlene Ducao                                        Search for:                                                            Synchronous Serial Communication: The Basics       Introduction Contents  1 Introduction  2 Serial Peripheral Interface (SPI)  3 Inter-Integrated Circuit (I2C) or Two-Wire Interface (TWI)  4 I2C Control of Multiple Microcontrollers  5 Conclusion    Related Video: Intro to Synchronous Serial   Asynchronous serial communication, which you can see in action in the Serial Output lab, is a common way for two computers to communicate. Both computers must have their own clock, and keep time independently of each other. This works well for personal computers, mobile devices, and microcontrollers because they all have their own clock crystal that acts as the processor&#8217;s heartbeat. However, there are simpler integrated circuits that have only one function, such as to read a sensor or to control a digital potentiometer or an oscillator to drive a PWM circuit. These ICs have no clock crystal of their own. They consist of a few memory registers and the minimal circuitry needed to connect these memory registers to the circuit that they control. To communicate with these ICs, you need to use synchronous serial communication.   To get the most out of these notes, you should know\u00a0 what a microcontroller is\u00a0 and have an understanding of the\u00a0 basics of microcontroller programming . You should also understand the\u00a0 basics of serial communication \u00a0as well.   Synchronous serial communication protocols feature a controller device which sends a clock pulse to one or more peripheral devices. The devices exchange a bit of data every time the clock changes. There are two common forms of synchronous serial, Inter-Integrated Circuit, or I2C (sometimes also called Two-Wire Interface, or TWI), and Serial Peripheral Interface, or SPI.   Synchronous serial devices communicate by shifting bits of data along their communication lines, like a bucket brigade. Data moved down the line one bit every time the clock pulses. All the devices in a synchronous serial chain share the same data and clock lines. Peripheral devices are directed by the controller device when to listen to the bits coming down the line, and when to ignore them. However, the two most common synchronous serial protocols, SPI and I2C, use different methods for directing the peripheral devices.   Serial Peripheral Interface (SPI)   Related Video: SPI     SPI devices are connected by four wires, as shown below:  a Serial Data In (SDI), on which the controller sends data to the peripheral devices. SDI is also sometimes referred to as Master Out, Slave In (MOSI) .   a Serial Data Out (SDO), on which the peripheral devices send data to the controller. SDO is also sometimes referred to as Master In, Slave Out (MISO)   a Clock \u00a0(SCLK) connection, on which the controller sends a regular clock signal to the peripheral devices.   one or more Chip Select (CS)\u00a0 connections, which the controller uses to signal the peripheral devices when to listen to incoming data and when to ignore it.     The SDI, SDO, and SCLK connections are shared between all the devices connected to the controller. This configuration is called a bus . Each peripheral has its own dedicated Chip Select connection to the controller, however.    A typical SPI bus configuration. The Controller&#8217;s output (MOSI) is the peripherals&#8217; input (SDI) and vice versa. Each peripheral gets its own Chip Select line. All other lines are shared.   When the controller device wants to communicate with one of the peripherals, it sets that device&#8217;s Chip Select pin low. The peripheral will then listen for new bits of data on the MOSI line every time the clock changes from low to high (called the rising edge of the clock). If it is instructed to send any data back, it will send data back to the controller when the clock signal changes from high to low (called the falling edge of the clock). When a peripheral device&#8217;s Chip Select pin is high, it will not respond to any commands sent on the SDI line.   The data exchange between SPI devices is usually shown like this:    A typical SPI data exchange. The Controller&#8217;s data (SDI or MOSI) are valid on the rising edge of the clock, while the Peripherals&#8217; data (SDO or MISO) are valid on the falling edge of the clock.   The Arduino&#8217;s SPI pins are determined by the processor. You can find the pins for the various models on the SPI library reference page . For the Arduino Uno, the pin numbers are pin 11 for MOSI, pin 12 for MISO, and pin 13 for Clock. Pin 10 is the default Chip Select pin, but you can use other pins for Chip Select as needed. The Arduino SPI library allows you to control the SPI bus. Most SPI devices that are compatible with Arduino come with their own libraries, however, which wrap the SPI library in commands specific to the device in question.   For example, the Analog Devices ADXL345 accelerometer can communicate via SPI. Its protocol works as follows: first the controller sets the ADXL345&#8217;s Chip Select pin low, then sends a command to the ADXL345 on the SDI (or MOSI) line to enter measurement mode. The ADXK345 then continually samples the accelerometer and stores the latest readings in three memory registers. When the controller wants to know those values, it sets the Chip Select pin low and sends a request to read those memory registers. The ADXL345 responds by sending back the contents of the memory registers on the SDO (MISO) line. When all the data has been received, the controller sets the Chip Select pin high again.   The advantage of SPI is that the data transactions are simple: all you need to do is to send the data to the device you&#8217;re communicating with. The disadvantage is that the number of wires needed to connect goes up by one for every peripheral device you add to the bus.    Data capture from a microcontroller communicating with an Analog Devices digital Potentiometer over SPI. The potentiometer sends no data, but the controller sends two bytes over the MOSI line.   Inter-Integrated Circuit (I2C) or Two-Wire Interface (TWI)   Related video: I2C   I2C is another popular synchronous serial protocol. It also uses a bus configuration like SPI, but there are only two connections between the controller device and the peripheral devices:     a Serial Clock (SCL) connection , on which the controller sends the clock signal, just as in SPI   a Serial Data (SDA) connection, on which the controller and peripherals exchange data in both directions.      I2C Bus diagram. Unlike the SPI diagram, only two connections are needed between controller and all the peripherals.   Each I2C peripheral device has a unique address on the bus. When the controller wants to communicate with a particular peripheral, it sends that peripheral&#8217;s address down the SDA connection, transferring each bit on the rising edge of the clock. An extra bit indicates whether the controller wants to write or read to the peripheral that it&#8217;s addressing. The appropriate peripheral then goes into listening mode, and the controller sends a command to the peripheral. Then the controller switches its connection to the SDA line from output to input. The peripheral then replies with the appropriate data, sending each bit on the falling edge of the clock. The controller switches its connection on the SDA line back to output once it&#8217;s received all of the data.   The I2C data capture below is typical (click to enlarge it). This is from a Texas Instruments TMP007 temperature sensor. The peripheral&#8217;s address is 0x40. First the controller sends a byte with 0x40 + 0 in the final bit, indicating that it plans to write a command to the peripheral. All of this data is sent valid on the rising edge of the clock. Then the controller sends a command, 0x03, which means &#8220;tell me your object&#8217;s\u00a0temperature&#8221; to this particular IC. Then the controller sends a byte with the peripheral&#8217;s\u00a0address again, 0x40 +1 in the final bit, indicating that it wants to read from the peripheral. The peripheral responds with two bytes, 0x0B and 0xC0. The controller then puts\u00a0those two bytes together to get the\u00a0object&#8217;s temperature (see the TMP007 datasheet if you want to know more)      The advantage of I2C is that you really only need two wires to connect all the I2C devices you want to your controller. The disadvantage is that you have to send an address before you send any command.   The Arduino&#8217;s I2C pins are determined by the processor. You can find the pins for the various models on the Wire\u00a0library reference page . The Arduino Wire library allows you to control the I2C bus. For the Arduino Uno, the pin numbers are analog pin 4 for SDA and analog pin 5 for SCL. On the Uno rev.3 layout, SDA and SCL are also broken out on the digital side of the board, next to the ground pin. \u00a0Most I2C devices that are compatible with Arduino come with their own libraries which wrap the Wire\u00a0library in commands specific to the device in question. For example, Adafruit&#8217;s library for the TMP007 relies on the Wire library to transmit and receive data.   I2C Control of Multiple Microcontrollers   You can also use I2C as a way to control many microcontrollers from one central controller. For example, if you needed to operate a large number of servomotors, you could put five or six each on a single Arduino, then chain several Arduinos together in an I2C chain and program them all to respond in slave mode . Then you would program a central controller in master mode , and have it send commands to the slave devices when it&#8217;s time to move each device&#8217;s servos. You can see an example of how to do this in this example from the Arduino site.   Conclusion   SPI and I2C are useful protocols because they allow you to interface with a wide variety of sensor and actuator ICs without having to use many of your microcontroller&#8217;s IO pins. Because they are both bus protocols, you can chain many devices on the same bus, and call on them only when needed from your microcontroller. For more on their usage, see the SPI Digital Potentiometer Lab and the I2C Contactless Temperature Sensor Lab.                                                 Proudly powered by WordPress"}, {"content": "Lab: Serial Communication with Node.js | ITP Physical Computing                                                          ITP Physical Computing             Search                  Primary Menu       Skip to content       Syllabus Phys-comp List Topics What Is Physical Computing? Electronics Electricity: the Basics Transistors, Relays, and Controlling High-Current Loads Understanding DC Power Supplies  Microcontrollers Microcontrollers: The Basics Digital Input &#038; Output Analog Input Analog Output  Programming Programming Terms and Programming Environments Variables  Sensors: the Basics Serial Communication Asynchronous Serial Communication: The Basics Interpreting Serial Data Synchronous Serial Communication: The Basics  DC Motors DC Motors: The Basics Controlling Stepper Motors  Videos Videos: Electricity Videos: Tools Videos: Schematic Diagrams Videos: Sensors Videos: Digital and Analog Input and Output Videos: Serial Communication Videos: Relays, Transistors, and Motors Videos: Prototyping Methods and Tips  Labs Labs: Electronics Lab: Components Lab: Setting Up A Breadboard Lab: Switches Lab: Soldering Lab: Electronics  Labs: Arduino Digital and Analog Lab: Digital Input and Output with an Arduino Lab: Analog In with an Arduino Lab: Servo Motor Control with an Arduino Lab: Tone Output Using An Arduino Lab: Sensor Change Detection  Labs: Serial Communication Lab: Serial Output from an Arduino Lab: Two-way (Duplex) Serial Communication using an Arduino Lab: MIDI Output using an Arduino Lab: Arduino to DAW Lab: Serial Communication with Node.js Lab: SPI Communication With A Digital Potentiometer Lab: I2C Communication With An Infrared Temperature Sensor  Labs: Motors and Transistors Lab: Using a Transistor to Control a High Current Load Lab: Using a Transistor to Control High Current Loads with an Arduino Lab: DC Motor Control Using an H-Bridge Lab: Controlling a Stepper Motor With an H-Bridge  Labs: Mouse Control Lab: Mouse Control Lab: Mouse Control With Pushbuttons Lab: Mouse Control With Joystick  Resources Books GitHub Repository Parts Needed for Physical Computing Additional Useful Parts and Tools Other Useful Sites Suppliers Checkout Components at ITP LittleBits Resources  Sections Tom Igoe Class Oct 1 Afternoon  Benedetta Piantella MONDAY WEDNESDAY  Jeff Feddersen Arlene Ducao                                        Search for:                                                            Lab: Serial Communication with Node.js       Introduction Contents  1 Introduction  2 Node.js  3 Hello from Node.js  4 The Node Serialport Library  4.1 Note: What&#8217;s With This Crazy Syntax?  5 Opening the Serial Port  5.1 The Program Won&#8217;t Stop!  6 Serialport Library Events  7 Serving Web Pages From Node  8 Using the\u00a0Data in HTML  8.1 Note: Check your data types     You can write programs that handle serial communication in many different languages. This page introduces how to do it using node.js. Node is a JavaScript environment usually user to write web server programs. Below, you&#8217;ll use it to connect a microcontroller to a web browser using the node.js programming environment, HTML, and JavaScript.   To get the most out of this tutorial, you should know what a microcontroller is and how to program them . You should also understand asynchronous serial communication between microcontrollers and personal computers. You should also understand the basics of command line interfaces .   You will struggle with this tutorial if you aren&#8217;t familiar with JavaScript. \u00a0For more on JavaScript, see Douglas Crockford&#8217;s JavaScript: The Good Parts, \u00a0Manuel Kiessling&#8217;s \u00a0the Node Beginner Book , or Shelley Powers&#8217; Learning Node .   Node.js   The JavaScript programming language is mainly used to add interactivity to web pages. All modern browsers include a JavaScript interpreter, which allows the browser to run JavaScript code that&#8217;s embedded in a web page. Google&#8217;s JavaScript engine is called v8 , and it&#8217;s available under an open source license. Node.js wraps the v8 engine up in an application programming interface that can run on personal computers and servers. On your personal computer, you run it through the command line interface.   Node was originally designed as a tool for writing server programs, but it can do much more. It has a library management system called node package manager or npm that allows you to extend its functionality in many directions. There is also an online registry of node libraries, npmjs.org . You can download libraries from this registry directly using npm. Below you&#8217;ll see npm used to add both serial communication functionality and a simple server programming library to node.   To get started, download the node.js installer and install it on your computer. Then open your command line terminal. On OSX, open the Terminal app, which can be found in the Applications/Utilities directory. On Windows, go to the start menu and type cmd then press enter to open a window to the command line.   Image: OSX and Windows command line interfaces   If you&#8217;ve never used a command line interface, check out this tutorial . \u00a0From here on out, you&#8217;ll see the command prompt indicated like this:   $      Any commands you need to type will follow the $ symbol. The actual command prompt will vary depending on your operating system. On Windows, it&#8217;s typically this: &gt; . On most Unix and Linux systems, including OSX, it&#8217;s $ .   When you&#8217;ve installed node.js, type this command at the command prompt to get the version of node that you&#8217;re running:   $ node -v     If you installed it correctly, you&#8217;ll get a version number like 0.10.29 . The node installer should also install the node package manager (npm). You can check that in the same way:   $ npm -v     Once node and npm are in place, you&#8217;re ready to create a new project.   Hello from Node.js   There&#8217;s a library for node.js that allows you to communicate over your computer&#8217;s serial ports called serialport. If your computer&#8217;s connected to the internet, you can download install it automatically using npm. Create a new directory for your project:   $ mkdir nodeSerialExample     Then change directories to that directory:   $ cd nodeSerialExample     Now make a new text file in that directory with the name index.js . \u00a0This will be your main program file. \u00a0Add the following text to the file:       console.log(&quot;Hello, and welcome to node.&quot;);       Save the file, then run it by typing the following on the command line:   $ node index.js   Your program should print out:   Hello, and welcome to node.   The program will finish and return to the command line when it&#8217;s done. Seeing that script running is indication that node.js is fully working on your machine.   You can also pass information into your node program using the process arguments on the command line. \u00a0Change your program like so:       var name = process.argv[2];  console.log(&quot;Hello, and welcome to node,&quot; + name);       Run this as you did before, but add your name after the name of your program when you invoke it, like so:   $ node index.js Tom     You&#8217;ll get the following:   Hello, and welcome to node, Tom     The command line arguments are passed to your program as an array. The name was the third word you typed, or array element 2 (counting &#8220;node&#8221; as element 0 and &#8220;index.js&#8221; as element 1). \u00a0This is a useful technique, and you&#8217;ll see it later to pass the program your serial port&#8217;s name.   The Node Serialport Library   You&#8217;ll also need the node serialport library, which you can install from the npm registry like so:   $ npm install serialport   This command will make a new subdirectory called node_modules, and in that directory it will install all the necessary assets for the serialport library. \u00a0You&#8217;ll see a lot of text go by, and hopefully no errors. If you get errors, consult npmjs.org and the github wiki\u00a0for serialport . Now you&#8217;re ready to use the serialport library.   The first thing you&#8217;ll want is a list of the serial ports.\u00a0Replace the text of your program file with the following:     var serialport = require(&quot;serialport&quot;);  var SerialPort = serialport.SerialPort;    // list serial ports:  serialport.list(function (err, ports) {   ports.forEach(function(port) {   console.log(port.comName);   });  });       Note: What&#8217;s With This Crazy Syntax?   If you&#8217;re new to JavaScript, this syntax may be confusing. Node.js examples tend to use anonymous functions frequently. JavaScript can pass functions as variables (and vice versa). \u00a0That&#8217;s what&#8217;s going on here.   Stoyan Stefanov&#8217;s JavaScript Patterns is useful for understanding the various patterns of JavaScript coding.     When you run this script, you&#8217;ll get a list of your serial ports like so:   $ node ListPorts.js   /dev/cu.Bluetooth-Incoming-Port  /dev/cu.Bluetooth-Modem  /dev/cu.usbmodem1411     If you&#8217;ve got an Arduino plugged in via USB, you should see the name of your board&#8217;s port there as well. In the example above, which was run on OSX, the Arduino&#8217;s port is\u00a0 /dev/cu.usbmodem1411 .   The process of using the serialport library will be the same every time:     initialize the serialport library   open the serial port   set up the callback functions and let them do the rest     Opening the Serial Port   To open a\u00a0serial port in node, you include the library at the beginning of\u00a0\u00a0your script, and make a local\u00a0instance of the library in a variable.\u00a0Make a new script or replace index.js with the following:     var serialport = require('serialport'),// include the library   SerialPort = serialport.SerialPort, // make a local instance of it   // get port name from the command line:   portName = process.argv[2];     Then you open the port using new() like so:     var myPort = new SerialPort(portName, {   baudRate: 9600,   // look for return and newline at the end of each data packet:   parser: serialport.parsers.readline(&quot;\\r\\n&quot;)   });     Note the serial parameters, which are passed to the new() function\u00a0after the port name, as a list. The first item is the baud rate, and the second is a parser, telling the serial library how to interpret data when it comes in. It should read all the incoming data as a line of text, and generate a new data event when it sees a carriage return and a newline (&#8220;\\r\\n&#8221;). The parser is doing the same thing as Processing&#8217;s Serial.bufferUntil() function does.   The Program Won&#8217;t Stop!   When you run this program now, it won&#8217;t automatically stop and return to the command line. To stop it, you&#8217;ll need to type control-C in the terminal window to stop it. \u00a0 The new instance of Serialport created a software object that listens for events from the serial port. Any node.js script that creates an event listener like this will run until you explicitly\u00a0stop it. \u00a0Both the serialport library and the http library, which you&#8217;ll use below, generate event listeners and will need to be explicitly stopped using control-C.   Serialport Library Events   The serialport library, like most node.js libraries, is event-based . This means that when the program is running, the operating system and the user&#8217;s actions will generate events and the program will provide functions to deal with those events called callback functions .   The main events that the serial library will deal with are when a\u00a0serial port opens, when it closes, when new data arrives, and when there&#8217;s an error.\u00a0The new data event in particular performs the same function as Processing&#8217;s serialEvent() function. \u00a0Once you&#8217;ve made an instance of the serialport library using the new() function as shown above, you define what functions will get called when each event occurs by using serialport.on() like so:     myPort.on('open', showPortOpen);  myPort.on('data', saveLatestData);  myPort.on('close', showPortClose);  myPort.on('error', showError);     The functions that are called by the event are the callback functions. In the example above, when the serial port is opened, the showPortOpen function will get called. When new data arrives, the saveLatestData function will get called, and so forth. If the event generates any parameters (for example a new data event will have the data as a parameter), those parameters will get passed to the callback function.   Write the callback functions for these events like so:     function showPortOpen() {   console.log('port open. Data rate: ' + myPort.options.baudRate);  }    function saveLatestData(data) {   console.log(data);  }    function showPortClose() {   console.log('port closed.');  }    function showError(error) {   console.log('Serial port error: ' + error);  }     Now you&#8217;ve got enough of a program to see some results. Upload a simple serial output sketch to your Arduino such as the AnalogReadSerial example or the sketch shown in the Analog Input Lab , you&#8217;ll be able to see its output from this script. Save the script. Then invoke it as follows, replacing portname with the name of your serial port:   $ node index.js portname   For example, on OSX, if you haven an Arduino attached to the serial port called\u00a0 /dev/cu.usbmodem1411 , then you&#8217;d type:   $ node index.js/dev/cu.usbmodem1411   When the port opens, you&#8217;ll see the message from the showPortOpen() function, then the output from the Arduino. Here&#8217;s the output from AnalogReadSerial:   port open. Data rate: 9600    266  276  261   To send serial output from node.js to the Arduino, use the serialport write() function like so:   myPort.write(\"Hello\");   That&#8217;s all it takes to read and write serial data from node.js to a microcontroller. Node.js is designed for writing web server applications, however, so in the following steps you&#8217;ll see how to connect a serial port to your web browser using more of node.js.   Serving Web Pages From Node   Node.js includes a http library for serving web pages, and Sam Lavigne&#8217;s servi library is a simplified interface for that library. \u00a0You&#8217;ll need it for what follows, so install it just like you installed the serialport library, using npm:   $ npm install servi   Once it&#8217;s successfully installed, include it with your previous script by adding the following at the beginning of \u00a0the script, right after you included\u00a0the serialport library:     var servi = require('servi');     Following that, you need to use new() to make a new instance of servi, and then configure a few parameters, and finally start the server:     var app = new servi(false); // servi instance  app.port(8080);    // port number to run the server on    // configure the server's behavior:  app.serveFiles(&quot;public&quot;);  // serve static HTML from public folder  app.route('/data', sendData); // route requests for /data to sendData()  // now that everything is configured, start the server:  app.start();     The server will operate on port 8080, so when you&#8217;re running this script on your computer, you&#8217;ll go to http://localhost:8080 in a browser to see the output. Your browser will be a client of the script, which will be running as a server. Any HTML files you place in a directory called public inside your application directory will be served to the client. But if the client asks for any URL that begins with http://localhost:8080/data , then a function called sendData will be run. Here it is. Add it to the end of your script:     function sendData(request) {   // print out the fact that a client HTTP request came in to the server:   console.log(&quot;Got a client request, sending them the data.&quot;);   // respond to the client request with the latest serial string:   request.respond(latestData);  }     You&#8217;ll notice a new variable, latestData, that&#8217;s not declared in this function. You&#8217;ll use it to pass values from the serial port to the server, so declare it as a global variable at the top of your script and give it an initial value of 0:     var latestData = 0;     Finally, you need to add the highlighted line below to the saveLatestData() function. This line will copy the latest incoming serial string into the latestData variable:     function saveLatestData(data) {   console.log(data);   latestData = data;  }     Now you&#8217;ve got a complete script for connecting serial data to a server, and serving that to a client through a browser. Run the script again as you did above, and then open a browser window and navigate to\u00a0 http://localhost:8080/data.\u00a0 You should get a page with just a single number in it:        Reload the page a few times, and the number will change with your Arduino&#8217;s analog input.   Using the\u00a0Data in HTML   The real value in connecting the serial port to a server is to generate dynamic HTML from the sensor data. You can do this by making an HTML page that includes some JavaScript to request data from the server, and serving that HTML page from a directory\u00a0called public in your project directory. First, create the directory and change directory into it:   $ mkdir public  $ cd public   Then create a new document, index.html, in this directory. Don&#8217;t enter any elements, just the bare skeleton of a page:     &lt;!DOCTYPE html&gt;  &lt;html&gt;   &lt;head&gt;   &lt;/head&gt;   &lt;body&gt;   &lt;/body&gt;  &lt;/html&gt;     If you&#8217;re used to Processing, then P5.js is a really good way to get started with JavaScript in the browser. It gives you the same structure as Processing, but in JavaScript. \u00a0To use it, you&#8217;ll need to include P5.js using script tags in the head of your HTML.   First, you need to include P5.js and its DOM manipulation library in the document head. You can either download P5.js and its libraries directly , or you can include them from P5&#8217;s content delivery site. The example below will do it the latter way.   Add an empty script tag as well, because that&#8217;s where you&#8217;ll write your code:     &lt;!DOCTYPE html&gt;  &lt;html&gt;   &lt;head&gt;   &lt;script src=&quot;//cdn.jsdelivr.net/p5.js/0.3.8/p5.min.js&quot;&gt;&lt;/script&gt;   &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.jsdelivr.net/p5.js/0.3.8/addons/p5.dom.js&quot;&gt;&lt;/script&gt;   &lt;script type=&quot;text/javascript&quot;&gt;   // your code will go here   &lt;/script&gt;   &lt;/head&gt;   &lt;body&gt;   &lt;/body&gt;  &lt;/html&gt;     P5.js uses setup() and draw() methods, just like Processing, and similar to Arduino. You&#8217;re going to create an HTML text div element\u00a0in the document, and in the loop, you&#8217;ll continually make requests back to the server for new serial data. When\u00a0you receive the serial data, you&#8217;ll use it to set the text, and later the position, of the text element. \u00a0Start with the setup() and draw() and a global variable for the text element like so (from here on out, the rest of the HTML will be omitted\u00a0for brevity. Everything you see below will be done in the head\u00a0of the document):      &lt;script type=&quot;text/javascript&quot;&gt;   var text; // variable for the text div you'll create     function setup() {   }     function draw() {   }   &lt;/script&gt;     In the setup function, create the text div and position it. Then make an initial HTTP call using the loadStrings() function to make a request to the server. You&#8217;ll request /data, which is the route you made in your server script earlier to return the sensor reading:      function setup() {   // make a new div and position it at 10, 10:   text = createDiv(&quot;Sensor reading:&quot;);   text.position(10,10);   // make a HTTP call to the server for the data:   var sensorReading = loadStrings(&quot;/data&quot;, showData);   }     Unlike in Processing, P5.js&#8217; loadScript function can take a callback function as a parameter. This function, called showData() below, \u00a0is called when the client has received the server&#8217;s\u00a0reply:      function showData(result) {   // when the server returns, show the result in the div:   text.html(&quot;Sensor reading:&quot; + result);   text.position(result, 10);   // make another HTTP call:   var sensorReading = loadStrings(&quot;/data&quot;, showData);  }     This function\u00a0changes the text inside the div. It also moves the div&#8217;s horizontal position. Note the last line of this function, it calls loadStrings again, and uses itself as a callback. This means it will basically run continually, so there&#8217;s no need for a draw() function.   Save this file in the public directory, then restart the server and browse to http://localhost:8080 in your browser. \u00a0You should see the text moving across the screen, depending on the sensor, as in the video below:     browser-animation from ITP on Vimeo .   Once you&#8217;ve got a server program serving data from a serial device to a browser, you have potential to make\u00a0all kinds dynamic interfaces that combine HTML and physical interfaces.   Notice that the server program doesn&#8217;t actually parse the serial data; it just treats it as a string, and passes that string on to the client. This means you can keep the server very simple, so you only need to make sure the two endpoints (the microcontroller and the client) are speaking the same protocol. JavaScript has many functions\u00a0for manipulating strings, particularly comma-separated values. So consider sending your data from Arduino as comma-separated values.     Note: Check your data types   When p5.js returns the result of a request, it returns the string as an array with one element.\u00a0If you&#8217;re planning on manipulating that string with functions like parseInt(), split() and other string handling functions, make sure to get\u00a0the string out of the array first. For example, if you&#8217;ve sent over the string:      &quot;234, 124, 134&quot;     and you want to split it, here&#8217;s how you&#8217;d do it:      function showData(result) {   var resultString = result[0];   text.html(&quot;Sensor reading:&quot; + resultString);   // split it:   var numbers = split(resultString, &quot;,&quot;);   // use the numbers:   text.position(numbers[0], numbers[1]);   text.style(&quot;font-size&quot;, numbers[2] + &quot;%&quot;);   }       For more info:     P5.js   Servi   node.js   node serialport     The full code for this lab can be found on gitHub .                                                 Proudly powered by WordPress"}]}]