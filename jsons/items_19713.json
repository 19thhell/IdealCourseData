[{"detail": [{"content": "/* Ordinary least squares estimation and time series data */  proc import out = armares    datafile = \"c:\\class\\ascii\\armares.dat\"    dbms = tab replace;    getnames=yes;    datarow = 2; run;  proc gplot data = armares;   plot yar*x; run;  /* Get the Durbin-Watson statistic using the dw option      */ proc reg data = armares;   model yar = x / dw;   output out=armares1_out   student = stdres; run;  /* Time series plot                */ proc timeplot data = armares1_out;   plot stdres='*'; run;  /* ACF plot                  */ proc autoreg data=armares;   model yar = x / nlag=20; run;  /* You can get a graphical ACF display in SAS for Windows. After executing  */ /* the commands above, click on             */ /*                    */ /*   Solutions --> Analysis --> Time Series Viewer      */ /*                    */ /* Highlight the \"WORK\" line under Libraries and the \"ARMARES1_OUT\" line  */ /* under SAS Data Sets. Then highlight \"stdres\" under Time Series variables. */ /* Enter \"x\" under Time ID. You must have a variable like this in the file  */ /* that gives the observation numbers. You can get this in a data step,   */ /* using the _N_ code for observation number. You also can get it using the  */ /* Create button in the Time Series Viewer. Now, click Graph. This gives  */ /* a time series plots of the residuals. There are four buttons on the right */ /* of the plot. The top one is already depressed, as it represents time series */ /* plot. Click on the second button to get the ACF plot (it's the first plot */ /* on the left). If you click on the bars in the ACF plot, the individual  */ /* numbers pop up.                */ /*                    */ /* I don't have code to do a runs test in SAS, but code is given at    */ /* http://support.sas.com/kb/33/092.html that you can try.      */ /*                    */ /* When you have the plots open in the Time Series Viewer, you will see seven */ /* buttons along the top. If you click on the fifth from the left, with a  */ /* triangle on it, you will get pictures that correspond to differencing the */ /* variable.                 */  /* The lag1 function lags the variable           */ data armares;   set armares;   lagyar = lag1(yar);   caseno = _N_; run;  proc gplot data = armares;   plot yar*lagyar; run;  proc reg data = armares;   model yar = lagyar / dw;   output out = armares2_out   student = stdres; run;  proc timeplot data = armares2_out;   plot stdres='*'; run;  proc autoreg data=armares;   model yar = lagyar / nlag=20; run;  /* Differencing the data is easy enough           */ data armares;   set armares;   diffyar = yar - lagyar; run;  proc univariate data = armares;   var diffyar; run;  /* Cochrane-Orcutt procedure             */ data armares;   set armares;   yarstar = yar - .69*lagyar;   xstar = x - .69*lag1(x); run;  proc reg data = armares;   model yarstar = xstar / dw;   output out = armares3_out   student = stdres; run;  proc timeplot data = armares3_out;   plot stdres='*'; run;  proc autoreg data=armares;   model yarstar = xstar / nlag=20; run;"}]},
{"detail": [{"content": "/* Ordinary least squares estimation and time series data */  proc import out = armares    datafile = \"c:\\class\\ascii\\armares.dat\"    dbms = tab replace;    getnames=yes;    datarow = 2; run;  proc gplot data = armares;   plot yar*x; run;  /* Get the Durbin-Watson statistic using the dw option      */ proc reg data = armares;   model yar = x / dw;   output out=armares1_out   student = stdres; run;  /* Time series plot                */ proc timeplot data = armares1_out;   plot stdres='*'; run;  /* ACF plot                  */ proc autoreg data=armares;   model yar = x / nlag=20; run;  /* You can get a graphical ACF display in SAS for Windows. After executing  */ /* the commands above, click on             */ /*                    */ /*   Solutions --> Analysis --> Time Series Viewer      */ /*                    */ /* Highlight the \"WORK\" line under Libraries and the \"ARMARES1_OUT\" line  */ /* under SAS Data Sets. Then highlight \"stdres\" under Time Series variables. */ /* Enter \"x\" under Time ID. You must have a variable like this in the file  */ /* that gives the observation numbers. You can get this in a data step,   */ /* using the _N_ code for observation number. You also can get it using the  */ /* Create button in the Time Series Viewer. Now, click Graph. This gives  */ /* a time series plots of the residuals. There are four buttons on the right */ /* of the plot. The top one is already depressed, as it represents time series */ /* plot. Click on the second button to get the ACF plot (it's the first plot */ /* on the left). If you click on the bars in the ACF plot, the individual  */ /* numbers pop up.                */ /*                    */ /* I don't have code to do a runs test in SAS, but code is given at    */ /* http://support.sas.com/kb/33/092.html that you can try.      */ /*                    */ /* When you have the plots open in the Time Series Viewer, you will see seven */ /* buttons along the top. If you click on the fifth from the left, with a  */ /* triangle on it, you will get pictures that correspond to differencing the */ /* variable.                 */  /* The lag1 function lags the variable           */ data armares;   set armares;   lagyar = lag1(yar);   caseno = _N_; run;  proc gplot data = armares;   plot yar*lagyar; run;  proc reg data = armares;   model yar = lagyar / dw;   output out = armares2_out   student = stdres; run;  proc timeplot data = armares2_out;   plot stdres='*'; run;  proc autoreg data=armares;   model yar = lagyar / nlag=20; run;  /* Differencing the data is easy enough           */ data armares;   set armares;   diffyar = yar - lagyar; run;  proc univariate data = armares;   var diffyar; run;  /* Cochrane-Orcutt procedure             */ data armares;   set armares;   yarstar = yar - .69*lagyar;   xstar = x - .69*lag1(x); run;  proc reg data = armares;   model yarstar = xstar / dw;   output out = armares3_out   student = stdres; run;  proc timeplot data = armares3_out;   plot stdres='*'; run;  proc autoreg data=armares;   model yarstar = xstar / nlag=20; run;"}, {"content": "Why does proc import hang on Unix?                                              Next: Working with WRDS datasets   Up: Reading in datasets   Previous: guessingrows             Why does proc import hang on Unix?   In some circumstances, when you run a SAS program on Unix with proc import (or proc export), the program reaches the import step and just sits there, not moving forward nor dying with an error. What may be happening is that proc import is trying to open an X-window telling you that it is running, and you are not running an X-windowing system.    To get around this, at the command prompt type         sas -noterminal myfile.sas &amp;   instead of     sas myfile.sas &amp;      This prevents SAS from trying to open an X-window to tell you about the progress of proc import. This also works with other procs that try to open windows: for instance, proc gplot.         Andre de Souza 2012-11-19"}]},
{"detail": [{"content": "/* Ordinary least squares estimation and time series data */  proc import out = armares    datafile = \"c:\\class\\ascii\\armares.dat\"    dbms = tab replace;    getnames=yes;    datarow = 2; run;  proc gplot data = armares;   plot yar*x; run;  /* Get the Durbin-Watson statistic using the dw option      */ proc reg data = armares;   model yar = x / dw;   output out=armares1_out   student = stdres; run;  /* Time series plot                */ proc timeplot data = armares1_out;   plot stdres='*'; run;  /* ACF plot                  */ proc autoreg data=armares;   model yar = x / nlag=20; run;  /* You can get a graphical ACF display in SAS for Windows. After executing  */ /* the commands above, click on             */ /*                    */ /*   Solutions --> Analysis --> Time Series Viewer      */ /*                    */ /* Highlight the \"WORK\" line under Libraries and the \"ARMARES1_OUT\" line  */ /* under SAS Data Sets. Then highlight \"stdres\" under Time Series variables. */ /* Enter \"x\" under Time ID. You must have a variable like this in the file  */ /* that gives the observation numbers. You can get this in a data step,   */ /* using the _N_ code for observation number. You also can get it using the  */ /* Create button in the Time Series Viewer. Now, click Graph. This gives  */ /* a time series plots of the residuals. There are four buttons on the right */ /* of the plot. The top one is already depressed, as it represents time series */ /* plot. Click on the second button to get the ACF plot (it's the first plot */ /* on the left). If you click on the bars in the ACF plot, the individual  */ /* numbers pop up.                */ /*                    */ /* I don't have code to do a runs test in SAS, but code is given at    */ /* http://support.sas.com/kb/33/092.html that you can try.      */ /*                    */ /* When you have the plots open in the Time Series Viewer, you will see seven */ /* buttons along the top. If you click on the fifth from the left, with a  */ /* triangle on it, you will get pictures that correspond to differencing the */ /* variable.                 */  /* The lag1 function lags the variable           */ data armares;   set armares;   lagyar = lag1(yar);   caseno = _N_; run;  proc gplot data = armares;   plot yar*lagyar; run;  proc reg data = armares;   model yar = lagyar / dw;   output out = armares2_out   student = stdres; run;  proc timeplot data = armares2_out;   plot stdres='*'; run;  proc autoreg data=armares;   model yar = lagyar / nlag=20; run;  /* Differencing the data is easy enough           */ data armares;   set armares;   diffyar = yar - lagyar; run;  proc univariate data = armares;   var diffyar; run;  /* Cochrane-Orcutt procedure             */ data armares;   set armares;   yarstar = yar - .69*lagyar;   xstar = x - .69*lag1(x); run;  proc reg data = armares;   model yarstar = xstar / dw;   output out = armares3_out   student = stdres; run;  proc timeplot data = armares3_out;   plot stdres='*'; run;  proc autoreg data=armares;   model yarstar = xstar / nlag=20; run;"}, {"content": "Why does proc import hang on Unix?                                              Next: Working with WRDS datasets   Up: Reading in datasets   Previous: guessingrows             Why does proc import hang on Unix?   In some circumstances, when you run a SAS program on Unix with proc import (or proc export), the program reaches the import step and just sits there, not moving forward nor dying with an error. What may be happening is that proc import is trying to open an X-window telling you that it is running, and you are not running an X-windowing system.    To get around this, at the command prompt type         sas -noterminal myfile.sas &amp;   instead of     sas myfile.sas &amp;      This prevents SAS from trying to open an X-window to tell you about the progress of proc import. This also works with other procs that try to open windows: for instance, proc gplot.         Andre de Souza 2012-11-19"}, {"content": "/* Estimating a demand function */  proc import out = gasdemand    datafile = \"c:\\class\\ascii\\demand2.dat\"    dbms = tab replace;    getnames=yes;    datarow = 2; run;  proc gplot data = gasdemand;   plot logGpc*logPG;   plot logGpc*Year; run;  /* Correlations of variables     */ proc corr data = gasdemand;   var logGpc logPG logI logPNC logPUC logPPT logPD logPN logPS YR; run;  proc reg data = gasdemand;   model logGpc = logPG logI logPNC logPUC logPPT logPD logPN logPS YR YRSQ / vif; run;  /* Best subsets regression is performed using the selection option   */ proc reg data = gasdemand;   model logGpc = logPG logI logPNC logPUC logPPT logPD logPN logPS YR YRSQ / selection = cp; run;  proc reg data = gasdemand;   model logGpc = logPG logI logPNC logPUC logPPT logPD logPN logPS YR YRSQ / selection = adjrsq; run;   /* The following macro was written by Zheng Sun and Yufeng Ding. It uses the  */ /* genmod procedure to order by AIC and AIC_C values a set of regression models */ /* I've included the entire macro here, but the proper approach is to save it */ /* in a file (say aicc.sas), and use the include statement when you need it:  */ /* %include 'c:\\class\\sas\\aicc.sas';            */  /* This would be the first line in the file aicc.sas            */ /* This macro can be used to calculate AICC and AIC of regression models using SAS Proc genmod. */ /* The output is also stored in the dataset named \"genmodsummary\" which can be called if needed. */ /* This macro was written by Zheng Sun and Yufeng Ding.           */  %Macro genmodsummary(data = ,    class=,    yvariable=,    model1=,    model2=,    model3=,       model4=,       model5=,       model6=,       model7=,       model8=,       model9 = ,       model10=,       model11= ,       model12= ,       model13= ,       model14= ,       model15= ,       model16= ,       model17= ,       model18= ,       model19= ,       model20= ,    distribution=,    link=,    offset=,    number_of_models=);   %do i = 1 %to &number_of_models;  %let model_name&i = &&model&i; %end;  %if (%length(&offset) EQ 0) %then %do;   %do i = 1 %to &number_of_models;   proc genmod data=&data;     class &class;     model &yvariable = &&model&i /dist=&distribution link=&link;     ods output  Modelfit = logtmp     ModelInfo = obstmp;   ods exclude ParameterEstimates Modelfit ModelInfo ClassLevels;    data loglikhd;   set logtmp;    modnum = &i;       where Criterion = 'Log Likelihood';         loglikhd = Value;   keep modnum loglikhd;      proc append base=result1 data = loglikhd force;      data dev;     set logtmp;       modnum = &i;       where Criterion = 'Deviance';         df=DF;         G2=Value;   keep modnum df G2;      proc append base=result2 data = dev force;      data obstmp;       set obstmp;       modnum=&i;       where Label1 = 'Observations Used';         ncells = nValue1;     keep modnum ncells;      proc append base=result3 data = obstmp force;    %end; %end;  %else %do;   %do i = 1 %to &number_of_models;     proc genmod data=&data;     class &class;     model &yvariable = &&model&i /dist=&distribution link=&link offset=&offset;     ods output  Modelfit = logtmp     ModelInfo = obstmp;   ods exclude ParameterEstimates Modelfit ModelInfo ClassLevels;      data loglikhd;   set logtmp;    modnum = &i;       where Criterion = 'Log Likelihood';         loglikhd = Value;     keep modnum loglikhd;      proc append base=result1 data = loglikhd force;      data dev;     set logtmp;       modnum = &i;    where Criterion = 'Deviance';         df=DF;         G2=Value;   keep modnum df G2;      proc append base=result2 data = dev force;      data obstmp;       set obstmp;       modnum=&i;       where Label1 = 'Observations Used';         ncells = nValue1;     keep modnum ncells;      proc append base=result3 data = obstmp force;   %end; %end;  data nobstmp; set &data; proc univariate noprint; var &yvariable; output out=result4tmp sum=nobstmp;  %do i = 1 %to &number_of_models; data result4tmp1; set result4tmp; modnum = &i; nobs=nobstmp; keep modnum nobs; proc append base=result4 data=result4tmp1 force; %end;  data genmodsummary;  merge result1 result2 result3 result4;   by modnum;  numpar=ncells-df;  %do i=1 %to &number_of_models;   if modnum =&i then model_name=\"&&model_name&i\";  %end;  %if (&distribution=normal) | (&distribution=n) %then %do;   data genmodsummary;   set genmodsummary;   numpar=numpar + 1;   aic= -2*loglikhd+2*(numpar);   aicc= -2*loglikhd+2*(numpar)*(ncells/(ncells-numpar-1)); %end; %else %do; %if (&distribution=p)|(&distribution=poisson) %then %do;   data genmodsummary;   set genmodsummary;   aic= G2+2*(numpar);   aicc= G2+2*(numpar)*(nobs/(nobs-numpar-1)); %end; %else %if (&distribution=nb) | (&distribution= negative binomial) %then %do;   data genmodsummary;   set genmodsummary;   numpar=numpar + 1;   aic= -2*loglikhd+2*(numpar);   aicc= -2*loglikhd+2*(numpar)*(nobs/(nobs-numpar-1));  %end; %end;   data genmodsummary; set genmodsummary;  proc sort;   by aic; data genmodsummary; set genmodsummary;  retain best;  if _n_=1 then best=aic;  daic=aic-best;  data genmodsummary; set genmodsummary;   proc sort;     by aicc; data genmodsummary; set genmodsummary;   retain best1;   if _n_=1 then best1=aicc;   daicc=aicc-best1;  data genmodsummary; set genmodsummary;   proc sort;     by modnum;  proc print data=genmodsummary noobs; var modnum model_name nobs ncells G2 df loglikhd numpar aic aicc daic daicc; run;  proc datasets library = work;   delete dev loglikhd logtmp nobstmp obstmp result1 result2 result3 result4 result4tmp result4tmp1; run; quit; %mend genmodsummary; /* This would be the last line in the file aicc.sas              */  /* Run the macro by putting in the models you wish to evaluate one at a time under model1,    */ /* model2, and so on. For least squares regression, use a normal distribution and identity link.   */ /* In the output nobs is the sum of the target variable values, while ncells is the number of   */ /* observations in the sample. You can ignore the entries under G2, DF, loglikhd, and numpar.    */ /* The entries under daic and daicc give the relative values of AIC and AIC_C, respectively, with  */ /* the model with minimal value having zero value.              */ %genmodsummary(data = gasdemand,     model1 = logI,     model2 = logI logPS,     model3 = logPG logI YRSQ,     model4 = logPG logI logPN logPS,     model5 = logPG logI logPD logPN logPS,     model6 = logPG logI logPUC logPD logPN logPS,     model7 = logPG logI logPUC logPPT logPD logPN logPS,     model8 = logPG logI logPUC logPPT logPD logPN logPS YR,     model9 = logPG logI logPUC logPPT logPD logPN logPS YR YRSQ,     model10 = logPG logI logPNC logPUC logPPT logPD logPN logPS YR YRSQ,     distribution=normal,      link=identity,     yvariable = logGpc,     number_of_models = 10);  proc reg data = gasdemand;   model logGpc = logPG logI logPUC logPPT logPD logPN logPS / vif; run;  proc reg data = gasdemand;   model logGpc = logPG logI logPUC logPD logPN logPS / vif; run;  proc reg data = gasdemand;   model logGpc = logPG logI logPD logPN logPS / vif;   output out = demandd_out    student = stdres    h = leverage    cookd = cooksd;   plot student.*predicted.; run;  proc print data = demandd_out;   var stdres leverage cooksd; run;  proc univariate data = demandd_out;   var stdres;   probplot; run;  /* Partial correlations       */ proc corr data = gasdemand;   var logGpc logPG; partial logI logPD logPN logPS; run;  /* Added variable plot calculations    */ proc reg data = gasdemand;   model logGpc = logI logPD logPN logPS;   output out = addvar1    r = adjcons;   model logPG = logI logPD logPN logPS;   output out = addvar2    r = adjprice; run;  data addvar;   merge addvar1 addvar2; run;  proc gplot data = addvar;   plot adjprice*adjcons; run;  proc reg data = gasdemand;   model logGpc = logPG logI YRSQ / vif;   output out = demande_out    student = stdres;   plot student.*predicted.;   plot student.*logPG;   plot student.*logI;   plot student.*YRSQ; run;  proc univariate data = demande_out;   var stdres;   probplot; run;"}]}]