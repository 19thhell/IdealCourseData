[{"detail": [{"content": "Beyond the Joystick: Take a Summer Class @ The Game Innovation Lab!                                                                                                                                       Menu       Skip to content       Menu Item 2   Menu Item 2   Menu Item 2   Menu Item 2   Menu Item 2                                        Menu       Skip to content        Home   About The Lab      People       Research      Sensual Evaluation Instrument    Fidget Widgets    RigMesh    Yamove!    Open Sesame    Pixel Motion    Scoop!    Beyond Passwords    SensoriMotor Rehabilitator    HUD &#038; Player Experience       News   Events      Indie Tech Talks    Alt-Ctrl Game Jam 2014       Contact Us                   Facebook        Twitter        Google+                             Search for:                                                                                                                             Beyond the Joystick: Take a Summer Class @ The Game Innovation Lab!                       May 30, 2012         There are still spots open for NYU and NYU-Poly students. Register right away!   Graduate Course #:   DM9103-1372   -OR-   CS9223-1372     At the Game Innovation Lab   Tuesdays &amp; Thursdays 1pm-3:50pm     Beyond the Joystick is an introduction to Physical Computing for students interested in exploring and building Alternative Physical Interfaces that can be used in games, toys and other interactive experiences. Through building simple prototypes, students will learn how to use a variety of switches and sensors, how to build circuits for them, and various ways Arduino and Processing can be used with them. We will study and discuss examples of existing interfaces and also brainstorm various scenarios the technology can be used in.                                                                                         Search for:                                                                                                                                           Events               No Upcoming Events                                          Gallery         Google+                                                               All content 2014 Game Innovation Lab and NYU Polytechnic School of Engineering. All rights Reserved."}]},
{"detail": [{"content": "Beyond the Joystick: Take a Summer Class @ The Game Innovation Lab!                                                                                                                                       Menu       Skip to content       Menu Item 2   Menu Item 2   Menu Item 2   Menu Item 2   Menu Item 2                                        Menu       Skip to content        Home   About The Lab      People       Research      Sensual Evaluation Instrument    Fidget Widgets    RigMesh    Yamove!    Open Sesame    Pixel Motion    Scoop!    Beyond Passwords    SensoriMotor Rehabilitator    HUD &#038; Player Experience       News   Events      Indie Tech Talks    Alt-Ctrl Game Jam 2014       Contact Us                   Facebook        Twitter        Google+                             Search for:                                                                                                                             Beyond the Joystick: Take a Summer Class @ The Game Innovation Lab!                       May 30, 2012         There are still spots open for NYU and NYU-Poly students. Register right away!   Graduate Course #:   DM9103-1372   -OR-   CS9223-1372     At the Game Innovation Lab   Tuesdays &amp; Thursdays 1pm-3:50pm     Beyond the Joystick is an introduction to Physical Computing for students interested in exploring and building Alternative Physical Interfaces that can be used in games, toys and other interactive experiences. Through building simple prototypes, students will learn how to use a variety of switches and sensors, how to build circuits for them, and various ways Arduino and Processing can be used with them. We will study and discuss examples of existing interfaces and also brainstorm various scenarios the technology can be used in.                                                                                         Search for:                                                                                                                                           Events               No Upcoming Events                                          Gallery         Google+                                                               All content 2014 Game Innovation Lab and NYU Polytechnic School of Engineering. All rights Reserved."}, {"content": "Lab: Mouse Control With Joystick | ITP Physical Computing                                                          ITP Physical Computing             Search                  Primary Menu       Skip to content       Syllabus Phys-comp List Topics What Is Physical Computing? Electronics Electricity: the Basics Transistors, Relays, and Controlling High-Current Loads Understanding DC Power Supplies  Microcontrollers Microcontrollers: The Basics Digital Input &#038; Output Analog Input Analog Output  Programming Programming Terms and Programming Environments Variables  Sensors: the Basics Serial Communication Asynchronous Serial Communication: The Basics Interpreting Serial Data Synchronous Serial Communication: The Basics  DC Motors DC Motors: The Basics Controlling Stepper Motors  Videos Videos: Electricity Videos: Tools Videos: Schematic Diagrams Videos: Sensors Videos: Digital and Analog Input and Output Videos: Serial Communication Videos: Relays, Transistors, and Motors Videos: Prototyping Methods and Tips  Labs Labs: Electronics Lab: Components Lab: Setting Up A Breadboard Lab: Switches Lab: Soldering Lab: Electronics  Labs: Arduino Digital and Analog Lab: Digital Input and Output with an Arduino Lab: Analog In with an Arduino Lab: Servo Motor Control with an Arduino Lab: Tone Output Using An Arduino Lab: Sensor Change Detection  Labs: Serial Communication Lab: Serial Output from an Arduino Lab: Two-way (Duplex) Serial Communication using an Arduino Lab: MIDI Output using an Arduino Lab: Arduino to DAW Lab: Serial Communication with Node.js Lab: SPI Communication With A Digital Potentiometer Lab: I2C Communication With An Infrared Temperature Sensor  Labs: Motors and Transistors Lab: Using a Transistor to Control a High Current Load Lab: Using a Transistor to Control High Current Loads with an Arduino Lab: DC Motor Control Using an H-Bridge Lab: Controlling a Stepper Motor With an H-Bridge  Labs: Mouse Control Lab: Mouse Control Lab: Mouse Control With Pushbuttons Lab: Mouse Control With Joystick  Resources Books GitHub Repository Parts Needed for Physical Computing Additional Useful Parts and Tools Other Useful Sites Suppliers Checkout Components at ITP LittleBits Resources  Sections Tom Igoe Class Oct 1 Afternoon  Benedetta Piantella MONDAY WEDNESDAY  Jeff Feddersen Arlene Ducao                                        Search for:                                                            Lab: Mouse Control With Joystick       Last edited 26 August 2014 by Benedetta Piantella   Introduction Contents  1 Introduction  2 What You\u2019ll Need to Know  3 Things You\u2019ll Need  3.1 Note on mouse control  4 Prepare the breadboard  5 Add a pushbutton  6 Add a thumb joystick  7 Program the module to read the pushbutton  8 Program the Leonardo to read the Joystick  9 Map the X and Y output readings  10 Add code to listen for the Joystick Select Button  10.1 Note on pullup vs. pulldown resistors  11 Add commands to control the mouse  11.1 Note on mouse misbehaving     In this lab, you&#8217;ll build an alternative computer mouse using an Arduino Leonardo using a joystick to move the mouse left, right, up and down. You&#8217;ll use the joystick&#8217;s select button to replace the mouse button as well. You&#8217;ll see how to scale the analog outputs of the joystick to a reasonable range using the map() function.   A joystick is typically made up of two potentiometers, one for the X axis and one for the Y axis. The potentiometers are mounted so that when the joystick is at rest in the center, the potentiometers are at the middle of their range. Some joysticks like the Thumb Joystsick used here also have a pushbutton that you can press by pushing down on the stick. (Note: SparkFun and Parallax have equivalent models as well.)   What You\u2019ll Need to Know   To get the most out of this lab, you should be familiar with the following concepts. You can check how to do so in the links below:     Digital Input with Arduino   Analog Input with Arduino   How to\u00a0 control a mouse   \u00a0 Mouse control with pushbuttons     Things You\u2019ll Need     For this lab you will need the following parts:                   Solderless Breadboard   22-AWG hook-up wire   Arduino Leonardo                    10kilohm resistors   Switch or pushbutton   Thumb Joystsick       Click on any image for a larger view     Note on mouse control   NOTE: The sketches contained in this lab will cause the Arduino Leonardo to take control of your mouse. Make sure they&#8217;re working properly before you add the mouse commands. The example doesn&#8217;t introduce the mouse commands until the end of the lab. Instead, messages are printed to the serial monitor to tell you what should happen. When you&#8217;ve run this and seen the serial messages occurring when you think they should, then you can add the mouse commands safely.   The sketches here will work on an Uno until you add the mouse commands. So you can test this on an Uno simply by commenting out any line that says Mouse.begin() or Mouse.move().    Prepare the breadboard   Connect power and ground on the breadboard to power and ground from the microcontroller. On the Arduino module, use the 5V and any of the ground connections:               Made with Fritzing       Add a pushbutton   Attach a pushbutton to digital pin 2. Connect one side of the pushbutton to 5 volts, and the other side of the pushbutton to a 10-kilohm resistor. Connect the other end of the resistor to ground. Connect the junction where the pushbutton and the resistor meet to digital pin 2. (For more on this digital input circuit,see the Digital Input Lab )                  Add a thumb joystick   Add a thumb joystick, attaching the Xout to analog input 0, the Yout to analog input 1, and the select button to digital input 3.                  Program the module to read the pushbutton   Follow the same steps as you did in the first Mouse Control lab to read when the pushbutton on pin 2 is pressed. Your code should only print out a message when the button changes state. Similarly, set up a global variable to track whether or not you&#8217;re controlling the mouse , called mouseIsActive. Each time the pushbutton on pin 2 is pressed, change the state of this variable from false to true, just like you did in the first mouse control lab.     // Global variables:  int lastButtonState = LOW;   // state of the button last time you checked  boolean mouseIsActive = false; // whether or not the Arduino is controlling the mouse    void setup() {   // initialize serial communication:   Serial.begin(9600);   pinMode(2, INPUT);  }    void loop() {   // read the first pushbutton:   int buttonState = digitalRead(2);     // if it's changed and it's high, toggle the mouse state:   if (buttonState != lastButtonState) {   if (buttonState == HIGH) {    // if mouseIsActive is true, make it false;    // if it's false, make it true:    mouseIsActive = !mouseIsActive;    Serial.print(&quot;Mouse control state: &quot;);    Serial.println(mouseIsActive);   }   }   // save button state for next comparison:   lastButtonState = buttonState;  }     Program the Leonardo to read the Joystick   Add code to the main loop to read the joystick X and Y outputs and print them.     // Global variables:  int lastButtonState = LOW;   // state of the button last time you checked  boolean mouseIsActive = false; // whether or not the Arduino is controlling the mouse    void setup() {   // initialize serial communication:   Serial.begin(9600);   pinMode(2, INPUT);  }    void loop() {   // read the first pushbutton:   int buttonState = digitalRead(2);     // if it's changed and it's high, toggle the mouse state:   if (buttonState != lastButtonState) {   if (buttonState == HIGH) {    // if mouseIsActive is true, make it false;    // if it's false, make it true:    mouseIsActive = !mouseIsActive;    Serial.print(&quot;Mouse control state: &quot;);    Serial.println(mouseIsActive);   }   }   // save button state for next comparison:   lastButtonState = buttonState;     // read the analog sensors:   int sensor1 = analogRead(A0);   delay(1);   int sensor2 = analogRead(A1);   // print their values. Remove this when you have things working:   Serial.print(sensor1);   Serial.print(&quot; &quot;);   Serial.println(sensor2);   }     Map the X and Y output readings   The Mouse.move() command has three parameters: the horizontal movement, the vertical movement, and the scroll wheel movement. All movements are relative, so Mouse.move(1,0,0); moves one pixel to the right; Mouse.move(-1,0,0); moves one pixel to the left; Mouse.move(0,1,0); moves one pixel down; and Mouse.move(0,-1,0); moves one pixel up. Moving the mouse more than about 5 pixels in any direction is a very fast move. So the ideal range for the joystick is if it can move the cursor 5 pixels in any direction.   In order to do this, you need to scale the X and Y outputs from the default range that they return (0 to 1023) to a range from -5 to 5. You can do this using the map() function. Map takes five parameters: the input value, the range of the input value, and the desired output range, like so:   result = map(inputValue, inputMinimum, inputMaximum, outputMinimum, outputMaximum);   So, if your input range is 0 to 1023, and your output range is -5 to 5, you might map like this:   result = map(sensorReading, 0, 1023, -5, 5);   Add code to the main loop to map the X and Y outputs to a range from -5 to 5. Print the mapped values instead of the original sensor values.     // read the analog sensors:   int sensor1 = analogRead(A0);   delay(1);   int sensor2 = analogRead(A1);     int xAxis = map(sensor1, 0, 1023, -5, 5);   int yAxis = map(sensor2, 0, 1023, -5, 5);     // print their values. Remove this when you have things working:   Serial.print(xAxis);   Serial.print(&quot; &quot;);   Serial.println(yAxis);     NOTE: If your joystick defaults to -1 at rest on one axis or both, try adding 1 to the result of the map command. Try different output ranges and see what they do.   When you run this sketch, you should see the Mouse Control State message once every time you press the first pushbutton, and the values of the X and Y axes of the joystick, mapped to a range of -5 to 5. You still need to add in the select button on the joystick, however.   Add code to listen for the Joystick Select Button   The joystick select button is a digital input, but it&#8217;s wired differently than the buttons you saw in the Digital Lab or the Mouse Control With Pushbuttons Lab .     Note on pullup vs. pulldown resistors   It is, in fact, wired to connect to ground when you press it. To read it, then, you&#8217;d still use digitalWrite(), but you&#8217;d expect it to go low when pressed instead of high. And instead of a pulldown resistor like you&#8217;ve used in those other two labs, you&#8217;d use a pullup resistor , so that it&#8217;s connected to 5V when the switch is not open.   You can see the schematic for a pullup resistor circuit below.      The Arduino has built-in pullup resistors that you can use on the digital inputs. When you set the pin to be an input using the pinMode() command, use the parameter INPUT_PULLUP instead of INPUT. This will activate the built-in pullup resistor on that pin, so you only have to attach a switch between the pin and ground.   The advantage of connecting your switch to ground instead of 5V is that you can use the internal pullup resistor instead of having to add an external resistor. The disadvantage is that your switch logic is inverted: HIGH means the switch is open, and LOW means it is closed. Most of the time you can wire your switches either way, but when you have a switch that&#8217;s already wired to ground like the select button in the joystick, you have to use the internal pullups and inverted logic.     Previously, you wired the select button to digital input 3. To read the select button in this sketch, add a pinMode command to the setup that makes it an INPUT_PULLUP. Then in the main loop, check if the mosueIsActive variable is true. If it is, then use digitalRead() to read the select button and store it in a local variable called button2State.   Add the following at the end of the setup command:      // make pin 2 an input, using the built-in pullup resistor:   pinMode(2, INPUT_PULLUP);     Then at the end of the loop, add the following code:      if (mouseIsActive == true) {    // read the second pushbutton:   int button2State = digitalRead(3);   }     The select button&#8217;s behavior should be like the mouse control pushbutton&#8217;s behavior: you only want something to happen when it changes. When the select button changes from off to on, you want it to perform a mouse click. When it changes from on to off, you want it to perform a mouse release. So you need to check for when the select button changes, just like you do with the other pushbutton.   To check for the select button to change, set up a global variable called lastButton2State to save its previous state. Then set up an if statement in the main loop after you read it to see if the current state and the previous state are different. If they are different, add another if statement to see if the current state is HIGH or LOW. If it&#8217;s LOW, then print &#8220;Mouse press&#8221; (remember,its logic is inverted). If the current state is HIGH, then print &#8220;mouse press&#8221;.   This block of code will look a lot like the code you used for Mouse Control to track the state change of the pushbutton on pin 2.   Add the following line before the setup command:      int lastButton2State = LOW;  // state of the other button last time you checked     Then inside the if statement that you added to check the mouseIsActive variable, add the following code (the if statement is shown here too):     if (mouseIsActive == true) {   // read the second pushbutton:   int button2State = digitalRead(3);     // if it's changed and it's high, toggle the mouse state:   if (button2State != lastButton2State) {    if (button2State == LOW) {    Serial.println(&quot;mouse pressed&quot;);    }     else {    Serial.println(&quot;mouse released&quot;);    }   }   // save second button state for next comparison:   lastButton2State = button2State;   }     When you run this code, you should see the words &#8220;mouse pressed&#8221; once when you press the select button, and &#8220;mouse released&#8221; when you release the select button. If it prints continually, you have an error.   When you&#8217;ve got that working, you&#8217;re ready to take control of the mouse.   Add commands to control the mouse     Note on mouse misbehaving   NOTE: The sketches contained in this lab will cause the Arduino Leonardo to take control of your mouse. Make sure they&#8217;re working properly before you add these commands. If your sketch causes your mouse to misbehave, upload a blank sketch (the default when you choose File -> New) to your Leonardo and you can start again from the beginning.    The Mouse.begin() command is called in the setup. It initializes mouse control from your Leonardo.   Modify the setup by adding the command Mouse.begin(). Then, in the loop where check if mouseIsActive is true, add Mouse.move commands to move as needed. Also add Mouse.press() when the select button is pressed, and Mouse.release() when it is released.   At the end of the setup(), add the following:      // initialize mouse control:   Mouse.begin();     Then in the main loop, add the following lines to the if statement that checks mouseIsActive:      if (mouseIsActive == true) {   Mouse.move(xAxis, yAxis, 0);     // read the second pushbutton:   int button2State = digitalRead(3);     // if it's changed and it's high, toggle the mouse state:   if (button2State != lastButton2State) {    if (button2State == LOW) {    Serial.println(&quot;mouse pressed&quot;);    Mouse.press();    }     else {    Serial.println(&quot;mouse released&quot;);    Mouse.release();     }   }     That&#8217;s the whole sketch. When you run this, press the mouse control pushbutton, then move the joystick and press the select button. You should have full mouse control.   The full sketch for this can be found on the phys comp github repository , called MouseMoveSimpleJoystick .   In this sketch, you can see the value of scaling an analog sensor&#8217;s readings to match the output range you need. Since the joystick potentiometers are at rest in the middle of their range, scaling them from -5 to 5 gives you easy control of the mouse movement, which is relative. You can also see how reading the state change of a digital input is important. You&#8217;re doing it for two different buttons in this sketch.                                                 Proudly powered by WordPress"}]},
{"detail": [{"content": "Beyond the Joystick: Take a Summer Class @ The Game Innovation Lab!                                                                                                                                       Menu       Skip to content       Menu Item 2   Menu Item 2   Menu Item 2   Menu Item 2   Menu Item 2                                        Menu       Skip to content        Home   About The Lab      People       Research      Sensual Evaluation Instrument    Fidget Widgets    RigMesh    Yamove!    Open Sesame    Pixel Motion    Scoop!    Beyond Passwords    SensoriMotor Rehabilitator    HUD &#038; Player Experience       News   Events      Indie Tech Talks    Alt-Ctrl Game Jam 2014       Contact Us                   Facebook        Twitter        Google+                             Search for:                                                                                                                             Beyond the Joystick: Take a Summer Class @ The Game Innovation Lab!                       May 30, 2012         There are still spots open for NYU and NYU-Poly students. Register right away!   Graduate Course #:   DM9103-1372   -OR-   CS9223-1372     At the Game Innovation Lab   Tuesdays &amp; Thursdays 1pm-3:50pm     Beyond the Joystick is an introduction to Physical Computing for students interested in exploring and building Alternative Physical Interfaces that can be used in games, toys and other interactive experiences. Through building simple prototypes, students will learn how to use a variety of switches and sensors, how to build circuits for them, and various ways Arduino and Processing can be used with them. We will study and discuss examples of existing interfaces and also brainstorm various scenarios the technology can be used in.                                                                                         Search for:                                                                                                                                           Events               No Upcoming Events                                          Gallery         Google+                                                               All content 2014 Game Innovation Lab and NYU Polytechnic School of Engineering. All rights Reserved."}, {"content": "Lab: Mouse Control With Joystick | ITP Physical Computing                                                          ITP Physical Computing             Search                  Primary Menu       Skip to content       Syllabus Phys-comp List Topics What Is Physical Computing? Electronics Electricity: the Basics Transistors, Relays, and Controlling High-Current Loads Understanding DC Power Supplies  Microcontrollers Microcontrollers: The Basics Digital Input &#038; Output Analog Input Analog Output  Programming Programming Terms and Programming Environments Variables  Sensors: the Basics Serial Communication Asynchronous Serial Communication: The Basics Interpreting Serial Data Synchronous Serial Communication: The Basics  DC Motors DC Motors: The Basics Controlling Stepper Motors  Videos Videos: Electricity Videos: Tools Videos: Schematic Diagrams Videos: Sensors Videos: Digital and Analog Input and Output Videos: Serial Communication Videos: Relays, Transistors, and Motors Videos: Prototyping Methods and Tips  Labs Labs: Electronics Lab: Components Lab: Setting Up A Breadboard Lab: Switches Lab: Soldering Lab: Electronics  Labs: Arduino Digital and Analog Lab: Digital Input and Output with an Arduino Lab: Analog In with an Arduino Lab: Servo Motor Control with an Arduino Lab: Tone Output Using An Arduino Lab: Sensor Change Detection  Labs: Serial Communication Lab: Serial Output from an Arduino Lab: Two-way (Duplex) Serial Communication using an Arduino Lab: MIDI Output using an Arduino Lab: Arduino to DAW Lab: Serial Communication with Node.js Lab: SPI Communication With A Digital Potentiometer Lab: I2C Communication With An Infrared Temperature Sensor  Labs: Motors and Transistors Lab: Using a Transistor to Control a High Current Load Lab: Using a Transistor to Control High Current Loads with an Arduino Lab: DC Motor Control Using an H-Bridge Lab: Controlling a Stepper Motor With an H-Bridge  Labs: Mouse Control Lab: Mouse Control Lab: Mouse Control With Pushbuttons Lab: Mouse Control With Joystick  Resources Books GitHub Repository Parts Needed for Physical Computing Additional Useful Parts and Tools Other Useful Sites Suppliers Checkout Components at ITP LittleBits Resources  Sections Tom Igoe Class Oct 1 Afternoon  Benedetta Piantella MONDAY WEDNESDAY  Jeff Feddersen Arlene Ducao                                        Search for:                                                            Lab: Mouse Control With Joystick       Last edited 26 August 2014 by Benedetta Piantella   Introduction Contents  1 Introduction  2 What You\u2019ll Need to Know  3 Things You\u2019ll Need  3.1 Note on mouse control  4 Prepare the breadboard  5 Add a pushbutton  6 Add a thumb joystick  7 Program the module to read the pushbutton  8 Program the Leonardo to read the Joystick  9 Map the X and Y output readings  10 Add code to listen for the Joystick Select Button  10.1 Note on pullup vs. pulldown resistors  11 Add commands to control the mouse  11.1 Note on mouse misbehaving     In this lab, you&#8217;ll build an alternative computer mouse using an Arduino Leonardo using a joystick to move the mouse left, right, up and down. You&#8217;ll use the joystick&#8217;s select button to replace the mouse button as well. You&#8217;ll see how to scale the analog outputs of the joystick to a reasonable range using the map() function.   A joystick is typically made up of two potentiometers, one for the X axis and one for the Y axis. The potentiometers are mounted so that when the joystick is at rest in the center, the potentiometers are at the middle of their range. Some joysticks like the Thumb Joystsick used here also have a pushbutton that you can press by pushing down on the stick. (Note: SparkFun and Parallax have equivalent models as well.)   What You\u2019ll Need to Know   To get the most out of this lab, you should be familiar with the following concepts. You can check how to do so in the links below:     Digital Input with Arduino   Analog Input with Arduino   How to\u00a0 control a mouse   \u00a0 Mouse control with pushbuttons     Things You\u2019ll Need     For this lab you will need the following parts:                   Solderless Breadboard   22-AWG hook-up wire   Arduino Leonardo                    10kilohm resistors   Switch or pushbutton   Thumb Joystsick       Click on any image for a larger view     Note on mouse control   NOTE: The sketches contained in this lab will cause the Arduino Leonardo to take control of your mouse. Make sure they&#8217;re working properly before you add the mouse commands. The example doesn&#8217;t introduce the mouse commands until the end of the lab. Instead, messages are printed to the serial monitor to tell you what should happen. When you&#8217;ve run this and seen the serial messages occurring when you think they should, then you can add the mouse commands safely.   The sketches here will work on an Uno until you add the mouse commands. So you can test this on an Uno simply by commenting out any line that says Mouse.begin() or Mouse.move().    Prepare the breadboard   Connect power and ground on the breadboard to power and ground from the microcontroller. On the Arduino module, use the 5V and any of the ground connections:               Made with Fritzing       Add a pushbutton   Attach a pushbutton to digital pin 2. Connect one side of the pushbutton to 5 volts, and the other side of the pushbutton to a 10-kilohm resistor. Connect the other end of the resistor to ground. Connect the junction where the pushbutton and the resistor meet to digital pin 2. (For more on this digital input circuit,see the Digital Input Lab )                  Add a thumb joystick   Add a thumb joystick, attaching the Xout to analog input 0, the Yout to analog input 1, and the select button to digital input 3.                  Program the module to read the pushbutton   Follow the same steps as you did in the first Mouse Control lab to read when the pushbutton on pin 2 is pressed. Your code should only print out a message when the button changes state. Similarly, set up a global variable to track whether or not you&#8217;re controlling the mouse , called mouseIsActive. Each time the pushbutton on pin 2 is pressed, change the state of this variable from false to true, just like you did in the first mouse control lab.     // Global variables:  int lastButtonState = LOW;   // state of the button last time you checked  boolean mouseIsActive = false; // whether or not the Arduino is controlling the mouse    void setup() {   // initialize serial communication:   Serial.begin(9600);   pinMode(2, INPUT);  }    void loop() {   // read the first pushbutton:   int buttonState = digitalRead(2);     // if it's changed and it's high, toggle the mouse state:   if (buttonState != lastButtonState) {   if (buttonState == HIGH) {    // if mouseIsActive is true, make it false;    // if it's false, make it true:    mouseIsActive = !mouseIsActive;    Serial.print(&quot;Mouse control state: &quot;);    Serial.println(mouseIsActive);   }   }   // save button state for next comparison:   lastButtonState = buttonState;  }     Program the Leonardo to read the Joystick   Add code to the main loop to read the joystick X and Y outputs and print them.     // Global variables:  int lastButtonState = LOW;   // state of the button last time you checked  boolean mouseIsActive = false; // whether or not the Arduino is controlling the mouse    void setup() {   // initialize serial communication:   Serial.begin(9600);   pinMode(2, INPUT);  }    void loop() {   // read the first pushbutton:   int buttonState = digitalRead(2);     // if it's changed and it's high, toggle the mouse state:   if (buttonState != lastButtonState) {   if (buttonState == HIGH) {    // if mouseIsActive is true, make it false;    // if it's false, make it true:    mouseIsActive = !mouseIsActive;    Serial.print(&quot;Mouse control state: &quot;);    Serial.println(mouseIsActive);   }   }   // save button state for next comparison:   lastButtonState = buttonState;     // read the analog sensors:   int sensor1 = analogRead(A0);   delay(1);   int sensor2 = analogRead(A1);   // print their values. Remove this when you have things working:   Serial.print(sensor1);   Serial.print(&quot; &quot;);   Serial.println(sensor2);   }     Map the X and Y output readings   The Mouse.move() command has three parameters: the horizontal movement, the vertical movement, and the scroll wheel movement. All movements are relative, so Mouse.move(1,0,0); moves one pixel to the right; Mouse.move(-1,0,0); moves one pixel to the left; Mouse.move(0,1,0); moves one pixel down; and Mouse.move(0,-1,0); moves one pixel up. Moving the mouse more than about 5 pixels in any direction is a very fast move. So the ideal range for the joystick is if it can move the cursor 5 pixels in any direction.   In order to do this, you need to scale the X and Y outputs from the default range that they return (0 to 1023) to a range from -5 to 5. You can do this using the map() function. Map takes five parameters: the input value, the range of the input value, and the desired output range, like so:   result = map(inputValue, inputMinimum, inputMaximum, outputMinimum, outputMaximum);   So, if your input range is 0 to 1023, and your output range is -5 to 5, you might map like this:   result = map(sensorReading, 0, 1023, -5, 5);   Add code to the main loop to map the X and Y outputs to a range from -5 to 5. Print the mapped values instead of the original sensor values.     // read the analog sensors:   int sensor1 = analogRead(A0);   delay(1);   int sensor2 = analogRead(A1);     int xAxis = map(sensor1, 0, 1023, -5, 5);   int yAxis = map(sensor2, 0, 1023, -5, 5);     // print their values. Remove this when you have things working:   Serial.print(xAxis);   Serial.print(&quot; &quot;);   Serial.println(yAxis);     NOTE: If your joystick defaults to -1 at rest on one axis or both, try adding 1 to the result of the map command. Try different output ranges and see what they do.   When you run this sketch, you should see the Mouse Control State message once every time you press the first pushbutton, and the values of the X and Y axes of the joystick, mapped to a range of -5 to 5. You still need to add in the select button on the joystick, however.   Add code to listen for the Joystick Select Button   The joystick select button is a digital input, but it&#8217;s wired differently than the buttons you saw in the Digital Lab or the Mouse Control With Pushbuttons Lab .     Note on pullup vs. pulldown resistors   It is, in fact, wired to connect to ground when you press it. To read it, then, you&#8217;d still use digitalWrite(), but you&#8217;d expect it to go low when pressed instead of high. And instead of a pulldown resistor like you&#8217;ve used in those other two labs, you&#8217;d use a pullup resistor , so that it&#8217;s connected to 5V when the switch is not open.   You can see the schematic for a pullup resistor circuit below.      The Arduino has built-in pullup resistors that you can use on the digital inputs. When you set the pin to be an input using the pinMode() command, use the parameter INPUT_PULLUP instead of INPUT. This will activate the built-in pullup resistor on that pin, so you only have to attach a switch between the pin and ground.   The advantage of connecting your switch to ground instead of 5V is that you can use the internal pullup resistor instead of having to add an external resistor. The disadvantage is that your switch logic is inverted: HIGH means the switch is open, and LOW means it is closed. Most of the time you can wire your switches either way, but when you have a switch that&#8217;s already wired to ground like the select button in the joystick, you have to use the internal pullups and inverted logic.     Previously, you wired the select button to digital input 3. To read the select button in this sketch, add a pinMode command to the setup that makes it an INPUT_PULLUP. Then in the main loop, check if the mosueIsActive variable is true. If it is, then use digitalRead() to read the select button and store it in a local variable called button2State.   Add the following at the end of the setup command:      // make pin 2 an input, using the built-in pullup resistor:   pinMode(2, INPUT_PULLUP);     Then at the end of the loop, add the following code:      if (mouseIsActive == true) {    // read the second pushbutton:   int button2State = digitalRead(3);   }     The select button&#8217;s behavior should be like the mouse control pushbutton&#8217;s behavior: you only want something to happen when it changes. When the select button changes from off to on, you want it to perform a mouse click. When it changes from on to off, you want it to perform a mouse release. So you need to check for when the select button changes, just like you do with the other pushbutton.   To check for the select button to change, set up a global variable called lastButton2State to save its previous state. Then set up an if statement in the main loop after you read it to see if the current state and the previous state are different. If they are different, add another if statement to see if the current state is HIGH or LOW. If it&#8217;s LOW, then print &#8220;Mouse press&#8221; (remember,its logic is inverted). If the current state is HIGH, then print &#8220;mouse press&#8221;.   This block of code will look a lot like the code you used for Mouse Control to track the state change of the pushbutton on pin 2.   Add the following line before the setup command:      int lastButton2State = LOW;  // state of the other button last time you checked     Then inside the if statement that you added to check the mouseIsActive variable, add the following code (the if statement is shown here too):     if (mouseIsActive == true) {   // read the second pushbutton:   int button2State = digitalRead(3);     // if it's changed and it's high, toggle the mouse state:   if (button2State != lastButton2State) {    if (button2State == LOW) {    Serial.println(&quot;mouse pressed&quot;);    }     else {    Serial.println(&quot;mouse released&quot;);    }   }   // save second button state for next comparison:   lastButton2State = button2State;   }     When you run this code, you should see the words &#8220;mouse pressed&#8221; once when you press the select button, and &#8220;mouse released&#8221; when you release the select button. If it prints continually, you have an error.   When you&#8217;ve got that working, you&#8217;re ready to take control of the mouse.   Add commands to control the mouse     Note on mouse misbehaving   NOTE: The sketches contained in this lab will cause the Arduino Leonardo to take control of your mouse. Make sure they&#8217;re working properly before you add these commands. If your sketch causes your mouse to misbehave, upload a blank sketch (the default when you choose File -> New) to your Leonardo and you can start again from the beginning.    The Mouse.begin() command is called in the setup. It initializes mouse control from your Leonardo.   Modify the setup by adding the command Mouse.begin(). Then, in the loop where check if mouseIsActive is true, add Mouse.move commands to move as needed. Also add Mouse.press() when the select button is pressed, and Mouse.release() when it is released.   At the end of the setup(), add the following:      // initialize mouse control:   Mouse.begin();     Then in the main loop, add the following lines to the if statement that checks mouseIsActive:      if (mouseIsActive == true) {   Mouse.move(xAxis, yAxis, 0);     // read the second pushbutton:   int button2State = digitalRead(3);     // if it's changed and it's high, toggle the mouse state:   if (button2State != lastButton2State) {    if (button2State == LOW) {    Serial.println(&quot;mouse pressed&quot;);    Mouse.press();    }     else {    Serial.println(&quot;mouse released&quot;);    Mouse.release();     }   }     That&#8217;s the whole sketch. When you run this, press the mouse control pushbutton, then move the joystick and press the select button. You should have full mouse control.   The full sketch for this can be found on the phys comp github repository , called MouseMoveSimpleJoystick .   In this sketch, you can see the value of scaling an analog sensor&#8217;s readings to match the output range you need. Since the joystick potentiometers are at rest in the middle of their range, scaling them from -5 to 5 gives you easy control of the mouse movement, which is relative. You can also see how reading the state change of a digital input is important. You&#8217;re doing it for two different buttons in this sketch.                                                 Proudly powered by WordPress"}, {"content": "Video Game Feedback May Help the Injured Heal | NYU Polytechnic School of Engineering                                                                                                     NYU Abu Dhabi | NYU Shanghai         QuickLinks Bulletin   Directory   Employment and Career Development   Events Calendar   Human Resources / Careers   Information Technology Systems   Library   Make a Gift   NYU Classes   NYUAlbert (PS DATA)   NYUHome   Records and Registration   Services and Resources   Students   Alumni   Faculty   Staff                          Admissions  Undergraduate Admissions Graduate Admissions Online Learning Financial Aid Accepted Undergraduates Accepted Graduates  Academics  Majors and Programs Departments Honors Program BS/MS Program Study Abroad Online Learning Support + Services Graduate School  Records and Registration Class Schedule Course Textbooks School Calendar Code of Conduct Bulletin Women in Engineering  Research  Message from the Associate Provost Sponsored Research Centers + Institutes Labs + Groups CITE Game Innovation Lab Cross-Institution \u201cSeed\u201d Research Undergraduate Summer Research Bern Dibner Library Institutional Research Bioengineering IT + Media Urban Systems  Outreach  Incubators NYC Media Lab NYC Seed Enterprise Learning Center for K12 STEM Education Employment and Career Development PowerBridgeNY  Student Life  Athletics Student Affairs Public Safety Graduate Student Life and Services International Students + Scholars Residence Life and Housing Services Student Activities and Resource Center Students with Disabilities Student Resources Student Orientation  About  Hours and Directions Leadership and Administration Mission News and Publications Campus Transformation Middle States Self-Study NYU Merger Past, Present, Future Giving                                          Home / News and Publications / Video Game Feedback May Help the Injured Heal                         Press Room                                                             Video Game Feedback May Help the Injured Heal         Researchers Demonstrate Therapeutic Applications for Off-the-Shelf Joysticks          Posted December 17th, 2013                Press Room  Facebook Twitter Print  Download Get Post Image                      \">   Brooklyn, N.Y.&mdash;Video gamers have long been familiar with the thrill of force feedback&mdash;the technology that allows players to feel the rumble of a racecar hitting a virtual road or sense the weight of wielding an on-screen sword. A team of researchers from the Polytechnic Institute of New York University (NYU-Poly) and Sapienza University of Rome have now published findings showing that force feedback is much more than fun. Combined with science learning in a therapeutic setting, it may even be healing.   A paper in the journal PLOS ONE details the experiments devised and performed by NYU-Poly&rsquo;s Maurizio Porfiri , associate professor of mechanical and aerospace engineering, and Oded Nov , associate professor of technology management and innovation, along with Professor Paolo Cappa, an NYU-Poly affiliated faculty member, and visiting master student Andrea Clerico of Sapienza University of Rome.   The use of robotic machines in physical therapy and rehabilitation has been evolving for more than two decades. So-called robot-mediated therapy (RMT) is viewed as too costly or complicated to implement in many care settings. However, haptic devices&mdash;those that provide tactile or force feedback&mdash;have become less expensive and are now integrated into gaming joysticks, personal computers, mobile devices, and other everyday technologies. The researchers wanted to test the utility of these haptic devices in physical rehabilitation. In a novel twist, they also incorporated science education elements into the experimental tasks to gauge if such content increased participants&rsquo; engagement with the exercises.   The team devised a series of experiments on 48 healthy test subjects to determine if force feedback delivered through a readily available, low-cost haptic gaming joystick would positively impact participants&rsquo; ability to complete on-screen tasks.   They created a 2D virtual map of a popular local attraction, New York City&rsquo;s Bronx Zoo, and asked participants to use the joystick to move a cursor along a set path through the zoo. Short paragraphs of science trivia and information about the zoo popped up along the course, and subjects were asked to read this content when presented.   Participants were subjected to several types of force feedback and a variety of assessments of their performance were calculated. The joystick delivered converging and diverging forces, pushing the cursor either toward or away from the proscribed path.   &ldquo;These conditions meant that subjects had to make continual adjustments to counter the force feedback and keep the cursor on track, which affected speed, smoothness, accuracy, and hand position,&rdquo; said Porfiri. &ldquo;The actions and movements we elicited are similar to the motor exercises used to rehabilitate upper-limb paralysis.&rdquo;   Perhaps one of the most significant findings was the impact of the learning modules. A post-task survey showed that the learning aspect increased participants&rsquo; interest and engagement in the activity. &ldquo;This has a particularly strong implication for rehabilitative therapies, as patients quickly grow bored of repetitive tasks,&rdquo; said Nov. &ldquo;If we can maintain engagement by incorporating some form of learning, there may be greater motivation to perform the tasks and reap the therapeutic benefits.&rdquo;   The research team believes that further studies are warranted, both to test the haptic device in patients with partially paralyzed upper limbs, and to test different types of learning content. The use of specially tuned affordable haptic devices may make it possible for patients to complete sophisticated rehabilitative tasks at home&mdash;and flex their mental muscles, too.   This research was supported by grants from the National Science Foundation, the Italian Ministry of Health Department of Medical Devices and Drugs, and the Honours Center of Italian Universities.   The paper, &ldquo;Can Force Feedback and Science Learning Enhance the Effectiveness of Neuro-Rehabilitation? An Experimental Study on Using a Low-Cost 3D Joystick and a Virtual Visit to a Zoo,&rdquo; is at http://www.plosone.org/article/info%3Adoi%2F10.1371%2Fjournal.pone.0083945#B1 .                         Learn more about: Oded Nov , Maurizio Porfiri                             News    Posted April 27th, 2015  Inno/Vention Demo Day: Learning by Demonstrating  As Attacks Multiply, AIG CEO Hancock Calls for Stronger Cyber Insurance Posted April 9th, 2015  The Jacobs Women: Helping Build a Legacy Posted March 26th, 2015  New Faculty, New Breakthroughs Posted March 19th, 2015        Cable   News from Cable alumni magazine.  Posted January 21st, 2015 Transformative Process Read More       Press Releases    Posted April 29th, 2015  Brookings Study Ranks NYU&#039;s Engineering School Among the Best in Aiding Students&#039; Financial Success  NYU School of Engineering Faculty and Students Share Their Cutting-Edge Research with the Public Posted April 20th, 2015  3 Promising Teams Win The #ConnectAbility Challenge Hackathon\u00a0 Posted April 20th, 2015                                 Engineering is NYU  Follow Us:  Facebook Twitter Vimeo YouTube        Undergraduate   Admissions   How to Apply   Apply Now   admissions@nyu.edu   Graduate   Admissions   Requirements   Apply Now   engineering.gradinfo@nyu.edu   Site Links   Press   Directory   Directions   Event Calendar   Careers/HR   Support    Email/Network help@poly.edu Website Report a Problem Login (Faculty + Staff)  NYU School of Engineering 6 MetroTech Center, Brooklyn, NY 11201 Tel: 718.260.3600 Fax: 718.260.3136 &copy; NYU School of Engineering"}]}]