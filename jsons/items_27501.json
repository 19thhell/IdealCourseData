[{"detail": [{"content": "Videos: Digital and Analog Input and Output | ITP Physical Computing                                                          ITP Physical Computing             Search                  Primary Menu       Skip to content       Syllabus Phys-comp List Topics What Is Physical Computing? Electronics Electricity: the Basics Transistors, Relays, and Controlling High-Current Loads Understanding DC Power Supplies  Microcontrollers Microcontrollers: The Basics Digital Input &#038; Output Analog Input Analog Output  Programming Programming Terms and Programming Environments Variables  Sensors: the Basics Serial Communication Asynchronous Serial Communication: The Basics Interpreting Serial Data Synchronous Serial Communication: The Basics  DC Motors DC Motors: The Basics Controlling Stepper Motors  Videos Videos: Electricity Videos: Tools Videos: Schematic Diagrams Videos: Sensors Videos: Digital and Analog Input and Output Videos: Serial Communication Videos: Relays, Transistors, and Motors Videos: Prototyping Methods and Tips  Labs Labs: Electronics Lab: Components Lab: Setting Up A Breadboard Lab: Switches Lab: Soldering Lab: Electronics  Labs: Arduino Digital and Analog Lab: Digital Input and Output with an Arduino Lab: Analog In with an Arduino Lab: Servo Motor Control with an Arduino Lab: Tone Output Using An Arduino Lab: Sensor Change Detection  Labs: Serial Communication Lab: Serial Output from an Arduino Lab: Two-way (Duplex) Serial Communication using an Arduino Lab: MIDI Output using an Arduino Lab: Arduino to DAW Lab: Serial Communication with Node.js Lab: SPI Communication With A Digital Potentiometer Lab: I2C Communication With An Infrared Temperature Sensor  Labs: Motors and Transistors Lab: Using a Transistor to Control a High Current Load Lab: Using a Transistor to Control High Current Loads with an Arduino Lab: DC Motor Control Using an H-Bridge Lab: Controlling a Stepper Motor With an H-Bridge  Labs: Mouse Control Lab: Mouse Control Lab: Mouse Control With Pushbuttons Lab: Mouse Control With Joystick  Resources Books GitHub Repository Parts Needed for Physical Computing Additional Useful Parts and Tools Other Useful Sites Suppliers Checkout Components at ITP LittleBits Resources  Sections Tom Igoe Class Oct 1 Afternoon  Benedetta Piantella MONDAY WEDNESDAY  Jeff Feddersen Arlene Ducao                                        Search for:                                                            Videos: Digital and Analog Input and Output       ITP Videos by Jeff Feddersen on Vimeo .  Watching time for\u00a0videos on this page: 82:43                                                                   Proudly powered by WordPress"}]},
{"detail": [{"content": "Videos: Digital and Analog Input and Output | ITP Physical Computing                                                          ITP Physical Computing             Search                  Primary Menu       Skip to content       Syllabus Phys-comp List Topics What Is Physical Computing? Electronics Electricity: the Basics Transistors, Relays, and Controlling High-Current Loads Understanding DC Power Supplies  Microcontrollers Microcontrollers: The Basics Digital Input &#038; Output Analog Input Analog Output  Programming Programming Terms and Programming Environments Variables  Sensors: the Basics Serial Communication Asynchronous Serial Communication: The Basics Interpreting Serial Data Synchronous Serial Communication: The Basics  DC Motors DC Motors: The Basics Controlling Stepper Motors  Videos Videos: Electricity Videos: Tools Videos: Schematic Diagrams Videos: Sensors Videos: Digital and Analog Input and Output Videos: Serial Communication Videos: Relays, Transistors, and Motors Videos: Prototyping Methods and Tips  Labs Labs: Electronics Lab: Components Lab: Setting Up A Breadboard Lab: Switches Lab: Soldering Lab: Electronics  Labs: Arduino Digital and Analog Lab: Digital Input and Output with an Arduino Lab: Analog In with an Arduino Lab: Servo Motor Control with an Arduino Lab: Tone Output Using An Arduino Lab: Sensor Change Detection  Labs: Serial Communication Lab: Serial Output from an Arduino Lab: Two-way (Duplex) Serial Communication using an Arduino Lab: MIDI Output using an Arduino Lab: Arduino to DAW Lab: Serial Communication with Node.js Lab: SPI Communication With A Digital Potentiometer Lab: I2C Communication With An Infrared Temperature Sensor  Labs: Motors and Transistors Lab: Using a Transistor to Control a High Current Load Lab: Using a Transistor to Control High Current Loads with an Arduino Lab: DC Motor Control Using an H-Bridge Lab: Controlling a Stepper Motor With an H-Bridge  Labs: Mouse Control Lab: Mouse Control Lab: Mouse Control With Pushbuttons Lab: Mouse Control With Joystick  Resources Books GitHub Repository Parts Needed for Physical Computing Additional Useful Parts and Tools Other Useful Sites Suppliers Checkout Components at ITP LittleBits Resources  Sections Tom Igoe Class Oct 1 Afternoon  Benedetta Piantella MONDAY WEDNESDAY  Jeff Feddersen Arlene Ducao                                        Search for:                                                            Videos: Digital and Analog Input and Output       ITP Videos by Jeff Feddersen on Vimeo .  Watching time for\u00a0videos on this page: 82:43                                                                   Proudly powered by WordPress"}, {"content": "Analog &larr; ICM                                                                                              ICM             Creative Computing                                            About   All Weeks   Switch   Software   Variation   Analog   Drawing   Animation   Scale   Telecommunication   Vision   Data                                                                                                                                               Analog Input and Output   The computer prefers things as yes or no but we inhabit a world with more nuance. \u00a0We need to make sure we don&#8217;t start conforming to the binary simplification of the world! \u00a0Analog in and analog out are going to make the variation be a little more variable. \u00a0Instead of just knowing &#8220;whether or not&#8221; something is happening in the world we will know &#8220;how much&#8221; it is happening. \u00a0Instead of just turning on and off an LED we can make it dimmer or brighter. \u00a0On a technical level analog reusese most of what you learned from digital input but gives you a bigger range of numbers than zero or one.   Analog Sensors   Variable resistors are the easiest type of analog sensors. \u00a0They vary in resistance with some other type of energy like heat, light, pressure etc. \u00a0Other types of analog sensors like accelerometers or microphones produce electricity instead of resisting it. \u00a0They are harder to work with so we will start with variable resistors .          Potentiometer             FSR Force Sensitive Resistor              Thermistor              Photocell                Flex Sensor              Stretch Sensor     Analog Input Circuit   For this circuit you have to use one of the pins on the Arduino labeled analog. \u00a0This circuit is just like the digital input circuit but your replace the switch with a variable resistor. \u00a0The resistance of the other resistor connected to ground depends on the variable resistor you use. \u00a0You want one that is pretty close to the maximum resistance of the variable resistor. \u00a0What you are making is called a &#8220;voltage divider circuit&#8221; where you want to give the electrons a difficult decision to make about which way to go. \u00a0Try swapping in different resistors for the non variable resistor until you get a good enough range of numbers.         Analog Read Functions   Now instead of digitalRead, you say analogRead. \u00a0Instead of it giving you a zero or one back it will give you a bigger range of numbers between 0 and 1024. \u00a0The particular range it sends you back will be idiosyncratic to each sensor.                                           void setup(){   pinMode(13,OUTPUT);  }    void loop(){   int input = analogRead(1);   if(input &lt; 800){ //this number depends on your sensors (see about println)   digitalWrite(13,HIGH);   } else{   digitalWrite(13,LOW);   }   Serial.println(input);  }                                     1 2 3 4 5 6 7 8 9 10 11 12 13                 void  setup ( ) {  pinMode ( 13 , OUTPUT ) ; }  void  loop ( ) {  int  input  =  analogRead ( 1 ) ;  if ( input  &lt;  800 ) {  //this number depends on your sensors (see about println)   digitalWrite ( 13 , HIGH ) ;  }  else {   digitalWrite ( 13 , LOW ) ;  }  Serial . println ( input ) ; }                                  Println   This command sends information back down the USB cable from the Arduino back to your laptop. \u00a0Ultimately you will use this to talk to your screenbased software in Processing. \u00a0For now it is very useful for debugging by checking what is inside variables. This is particularly useful for seeing the range of values that your analog sensors give back to you.     You have to first set up the Serial connection in setup.   Then you can send back variables to look at by saying Serial.prinln(varName) in loop.   Finally you have to remember to \u00a0click open the serial monitor using the magnifying glass icon on the top right in the Arduino software on your laptop.                                               void setup(){   Serial.begin(9600);  }    void loop(){   int input = analogRead(1);   Serial.println(input);   //don't forget to click open serial monitor  }                                     1 2 3 4 5 6 7 8 9                 void  setup ( ) {  Serial . begin ( 9600 ) ; }  void  loop ( ) {  int  input  =  analogRead ( 1 ) ;  Serial . println ( input ) ;  //don't forget to click open serial monitor }                                       The Special Case of a Pot   A potentiometer is behind most &#8220;knobs&#8221; and is the archetypal analogy sensor. \u00a0In this class we are trying to extend interface to accommodate expression beyond the turning of knobs so in a way this is the least interesting of the usual suspects listed above. \u00a0What \u00a0potentiometers have going in their favor is that they give you back a perfect and full range of numbers from 0 to 1024. \u00a0Remember in the analog input circuit was a &#8220;voltage dividing&#8221; with two resistors? \u00a0Well the voltage dividing circuit is built into the mechanism of the potentiometer so that the center &#8220;wiper&#8221; divides the resistive material into two resistors which are in a perfectly \u00a0complementary balance to each other.        Analog Ouput   I am sure you already found analog input to more fun than just a swtich. \u00a0You can dim the usual LED instead of just turning it on and off. \u00a0You can hit different pitches on the buzzer. \u00a0Probably best of all you can send you servo motor to variable positions. \u00a0But you are limited to some degree by the fact that the 5V and 20milliamps coming out of the microcontroller pin is too little to be very bright, make much noise or move something big. \u00a0For that you would have add an intermediary \u00a0like a transistor to boost the power. \u00a0In the meantime there is plenty of fun you can have with these devices.   PWM   Your micronconroller is really only capable of on or off, so it fakes an analog circuit with with a technique called PWM or Pulse Width Modulation. \u00a0Basically it turns the pin on and off really fast. \u00a0When it leaves the pin on for longer than off, it has the feeling of being brighter. \u00a0Look at the two graphs below. \u00a0As you can imagine an LED attached to a pin with wider pulses, that is the pulses left on for longer will look brighter than the LED with the narrower pulses. \u00a0In truth the LED is really only on or off but your persistence of vision makes it look dimmer or brighter.\u00a0Even the longer pulses are on the order of microseconds so we don&#8217;t see the flicker.       Analog Out LED Circuit   \u00a0or\u00a0   You could also just use the old digital output circuit from last week and it would or okay but the one with capacitor is better (see below). \u00a0Make sure you connect to one of the pins marked for \u00a0PWM pins on your micro controller (look for a &#8220;~&#8221; next to the pins on a uno). \u00a0The advantage of these pins is the microcontroller will keep sending out that pattern of pulses in the background even when it moved on to another line of code that does something else.   Capacitors (optional read)      To help hide the flicker further this you will see a capacitor in the circuit. \u00a0This is the last of the major electronic components, resistors, diodes and capacitors. \u00a0A capacitor acts as a savings bank storing up energy when time are good and current is flowing. \u00a0When electricity stops flowing it discharges the stored energy filling in the blanks. \u00a0In this way it acts as a smoothing filter. \u00a0\u00a0 \u00a0This\u00a0If you\u2019re dimming an LED, start with a 10\u00b5f capacitor and a 220-ohm resistor, and experiment with different values from there to see what works best. \u00a0Some capacitors are polarized (it matter which leg is which). \u00a0You should see a minus sign on the casing of capacitor to indicate the polarity. \u00a0y.   Analog Output of Tones   If you connect a piezo buzzer to your circuit you can make some noise (you might want to do make sure you are alone because it is not av very pleasing sound). \u00a0The circuit is very easy, just one pin to ground and the other connected to an Arduino pin. \u00a0You will hear a click on and off if you try digitalWrite. \u00a0AnalogWrite will create a tone because the quick pulses will start some vibration but varying it will not be very satisfying. \u00a0If \u00a0you look at those graphs above they might look roughly like sound waves but if you look carefully even though they have different widths, they all start at the same intervals. \u00a0The interval between the waves determines how frequently they come along thus the frequency or pitch of the sound. \u00a0If you want to change the pitch of the sound you have take either take finer control by turning \u00a0on and off the wave for\u00a0 precise periods of microseconds\u00a0 or better yet use the tone command .                                           void setup() {    }    void loop() {   // turn off tone function for pin 9:   noTone(9);      // play a note on pin 9 for 200 ms:   tone(9, 440, 200);   delay(200);     // turn off tone function for pin 9:   noTone(9);   // play a note on pin 9 for 500 ms:   tone(9, 494, 500);   delay(500);     // turn off tone function for pin 9:   noTone(9);    // play a note on pin 9 for 500 ms:   tone(9, 523, 300);   delay(300);  }                                     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23                 void  setup ( )  {  }  void  loop ( )  {  // turn off tone function for pin 9:  noTone ( 9 ) ;      // play a note on pin 9 for 200 ms:  tone ( 9 ,  440 ,  200 ) ;  delay ( 200 ) ;   // turn off tone function for pin 9:  noTone ( 9 ) ;  // play a note on pin 9 for 500 ms:  tone ( 9 ,  494 ,  500 ) ;  delay ( 500 ) ;   // turn off tone function for pin 9:  noTone ( 9 ) ;   // play a note on pin 9 for 500 ms:  tone ( 9 ,  523 ,  300 ) ;  delay ( 300 ) ; }                                  Analog Output with Servo Motors   For really big fun you should play with servo motors. \u00a0With most motors you give them power and they spin. \u00a0Servo motors are different. \u00a0You give the a pulse of a particular duration or &#8220;width&#8221; and they turn to a corresponding angle. \u00a0For instance you give them a short pulse and they turn to zero degrees and you give them the longest pulse and they turn to 180 degrees (they usually can&#8217;t go all the way around).    Visit Liz Arum&#8217;s Page on This   Servo Connection   Servos usually come with three wires, black for ground, red for 5 V, and then another color the &#8220;signal&#8221; wire that you send a pulse to. \u00a0The end of the wire of a servo is typically a header with three holes which is too much like the holes in your breadboard to fit together. \u00a0If you can get your hands on some header posts it works nicely, otherwise stick some jumper wires in there.   \u00a0   Servo Software   You can create the pulse manually by turning on and off a pin using digitalWrite with microsecond precision. \u00a0Otherwise you can use the the servo library to make it a little easier. \u00a0You will notice in this code that there is an include statement at the top the refers to a library. \u00a0A library is an add on piece of code that is not part of the core processing code. \u00a0Luckily for you this library comes with the standard download of the Arduino environment so you don&#8217;t have to do anything except mention at the top that you intend to use it by saying #include &lt;Servo.h&gt; \u00a0.   Hard Way   digitalWrite(motoPin,HIGH);  delayMicroseconds(1850);  digitalWrite(motoPin,LOW);  delayMicroseconds(1850);   Easier Way Using Servo library                                           #include &lt;Servo.h&gt;  // include the servo library    Servo servoMotor;  // creates an instance of the servo object to control a servo    void setup() {   Serial.begin(9600);  // initialize serial communications   servoMotor.attach(2); // attaches the servo on pin 2 to the servo object  }    void loop()  {   int analogValue = analogRead(A0); // read the analog input   //Serial.println(analogValue);  // print it     // if your sensor's range is less than 0 to 1023, you'll need to   // modify the map() function to use the values you discovered:   int servoAngle = map(analogValue, 730, 980, 0, 179);   Serial.println(servoAngle);     // move the servo using the angle from the sensor:   servoMotor.write(servoAngle);  }                                     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22                 #include &lt;Servo.h&gt;  // include the servo library  Servo servoMotor ;   // creates an instance of the servo object to control a servo  void  setup ( )  {  Serial . begin ( 9600 ) ;   // initialize serial communications  servoMotor . attach ( 2 ) ;  // attaches the servo on pin 2 to the servo object }  void  loop ( ) {  int  analogValue  =  analogRead ( A0 ) ;  // read the analog input  //Serial.println(analogValue);  // print it   // if your sensor's range is less than 0 to 1023, you'll need to  // modify the map() function to use the values you discovered:  int  servoAngle  =  map ( analogValue ,  730 ,  980 ,  0 ,  179 ) ;  Serial . println ( servoAngle ) ;   // move the servo using the angle from the sensor:  servoMotor . write ( servoAngle ) ; }                                  You will also see a new function called map in this code. \u00a0Because the numbers we are getting in from some random analog sensor are unlikely to the exact numbers that some random servo want, you will have to do a like math to massage them. \u00a0Map does this for you. \u00a0You give it the number you want to convert in a variable, the range from the input, and the range for the output and it will return a number in the output range that is proportionate to the input number in the input range.   \u00a0You Don&#8217;t Really Need to Read Further   Analog Ouput Amplified with a Transitor   To power bigger motors or speakers or lights you will need and intermediary like a transistor. \u00a0http://itp.nyu.edu/physcomp/Tutorials/HighCurrentLoads                                                                                             Leave a Reply Cancel Reply            You must be logged in to post a comment.                                                       &copy; 2015 ICM &mdash; All Rights Reserved."}]},
{"detail": [{"content": "Videos: Digital and Analog Input and Output | ITP Physical Computing                                                          ITP Physical Computing             Search                  Primary Menu       Skip to content       Syllabus Phys-comp List Topics What Is Physical Computing? Electronics Electricity: the Basics Transistors, Relays, and Controlling High-Current Loads Understanding DC Power Supplies  Microcontrollers Microcontrollers: The Basics Digital Input &#038; Output Analog Input Analog Output  Programming Programming Terms and Programming Environments Variables  Sensors: the Basics Serial Communication Asynchronous Serial Communication: The Basics Interpreting Serial Data Synchronous Serial Communication: The Basics  DC Motors DC Motors: The Basics Controlling Stepper Motors  Videos Videos: Electricity Videos: Tools Videos: Schematic Diagrams Videos: Sensors Videos: Digital and Analog Input and Output Videos: Serial Communication Videos: Relays, Transistors, and Motors Videos: Prototyping Methods and Tips  Labs Labs: Electronics Lab: Components Lab: Setting Up A Breadboard Lab: Switches Lab: Soldering Lab: Electronics  Labs: Arduino Digital and Analog Lab: Digital Input and Output with an Arduino Lab: Analog In with an Arduino Lab: Servo Motor Control with an Arduino Lab: Tone Output Using An Arduino Lab: Sensor Change Detection  Labs: Serial Communication Lab: Serial Output from an Arduino Lab: Two-way (Duplex) Serial Communication using an Arduino Lab: MIDI Output using an Arduino Lab: Arduino to DAW Lab: Serial Communication with Node.js Lab: SPI Communication With A Digital Potentiometer Lab: I2C Communication With An Infrared Temperature Sensor  Labs: Motors and Transistors Lab: Using a Transistor to Control a High Current Load Lab: Using a Transistor to Control High Current Loads with an Arduino Lab: DC Motor Control Using an H-Bridge Lab: Controlling a Stepper Motor With an H-Bridge  Labs: Mouse Control Lab: Mouse Control Lab: Mouse Control With Pushbuttons Lab: Mouse Control With Joystick  Resources Books GitHub Repository Parts Needed for Physical Computing Additional Useful Parts and Tools Other Useful Sites Suppliers Checkout Components at ITP LittleBits Resources  Sections Tom Igoe Class Oct 1 Afternoon  Benedetta Piantella MONDAY WEDNESDAY  Jeff Feddersen Arlene Ducao                                        Search for:                                                            Videos: Digital and Analog Input and Output       ITP Videos by Jeff Feddersen on Vimeo .  Watching time for\u00a0videos on this page: 82:43                                                                   Proudly powered by WordPress"}, {"content": "Analog &larr; ICM                                                                                              ICM             Creative Computing                                            About   All Weeks   Switch   Software   Variation   Analog   Drawing   Animation   Scale   Telecommunication   Vision   Data                                                                                                                                               Analog Input and Output   The computer prefers things as yes or no but we inhabit a world with more nuance. \u00a0We need to make sure we don&#8217;t start conforming to the binary simplification of the world! \u00a0Analog in and analog out are going to make the variation be a little more variable. \u00a0Instead of just knowing &#8220;whether or not&#8221; something is happening in the world we will know &#8220;how much&#8221; it is happening. \u00a0Instead of just turning on and off an LED we can make it dimmer or brighter. \u00a0On a technical level analog reusese most of what you learned from digital input but gives you a bigger range of numbers than zero or one.   Analog Sensors   Variable resistors are the easiest type of analog sensors. \u00a0They vary in resistance with some other type of energy like heat, light, pressure etc. \u00a0Other types of analog sensors like accelerometers or microphones produce electricity instead of resisting it. \u00a0They are harder to work with so we will start with variable resistors .          Potentiometer             FSR Force Sensitive Resistor              Thermistor              Photocell                Flex Sensor              Stretch Sensor     Analog Input Circuit   For this circuit you have to use one of the pins on the Arduino labeled analog. \u00a0This circuit is just like the digital input circuit but your replace the switch with a variable resistor. \u00a0The resistance of the other resistor connected to ground depends on the variable resistor you use. \u00a0You want one that is pretty close to the maximum resistance of the variable resistor. \u00a0What you are making is called a &#8220;voltage divider circuit&#8221; where you want to give the electrons a difficult decision to make about which way to go. \u00a0Try swapping in different resistors for the non variable resistor until you get a good enough range of numbers.         Analog Read Functions   Now instead of digitalRead, you say analogRead. \u00a0Instead of it giving you a zero or one back it will give you a bigger range of numbers between 0 and 1024. \u00a0The particular range it sends you back will be idiosyncratic to each sensor.                                           void setup(){   pinMode(13,OUTPUT);  }    void loop(){   int input = analogRead(1);   if(input &lt; 800){ //this number depends on your sensors (see about println)   digitalWrite(13,HIGH);   } else{   digitalWrite(13,LOW);   }   Serial.println(input);  }                                     1 2 3 4 5 6 7 8 9 10 11 12 13                 void  setup ( ) {  pinMode ( 13 , OUTPUT ) ; }  void  loop ( ) {  int  input  =  analogRead ( 1 ) ;  if ( input  &lt;  800 ) {  //this number depends on your sensors (see about println)   digitalWrite ( 13 , HIGH ) ;  }  else {   digitalWrite ( 13 , LOW ) ;  }  Serial . println ( input ) ; }                                  Println   This command sends information back down the USB cable from the Arduino back to your laptop. \u00a0Ultimately you will use this to talk to your screenbased software in Processing. \u00a0For now it is very useful for debugging by checking what is inside variables. This is particularly useful for seeing the range of values that your analog sensors give back to you.     You have to first set up the Serial connection in setup.   Then you can send back variables to look at by saying Serial.prinln(varName) in loop.   Finally you have to remember to \u00a0click open the serial monitor using the magnifying glass icon on the top right in the Arduino software on your laptop.                                               void setup(){   Serial.begin(9600);  }    void loop(){   int input = analogRead(1);   Serial.println(input);   //don't forget to click open serial monitor  }                                     1 2 3 4 5 6 7 8 9                 void  setup ( ) {  Serial . begin ( 9600 ) ; }  void  loop ( ) {  int  input  =  analogRead ( 1 ) ;  Serial . println ( input ) ;  //don't forget to click open serial monitor }                                       The Special Case of a Pot   A potentiometer is behind most &#8220;knobs&#8221; and is the archetypal analogy sensor. \u00a0In this class we are trying to extend interface to accommodate expression beyond the turning of knobs so in a way this is the least interesting of the usual suspects listed above. \u00a0What \u00a0potentiometers have going in their favor is that they give you back a perfect and full range of numbers from 0 to 1024. \u00a0Remember in the analog input circuit was a &#8220;voltage dividing&#8221; with two resistors? \u00a0Well the voltage dividing circuit is built into the mechanism of the potentiometer so that the center &#8220;wiper&#8221; divides the resistive material into two resistors which are in a perfectly \u00a0complementary balance to each other.        Analog Ouput   I am sure you already found analog input to more fun than just a swtich. \u00a0You can dim the usual LED instead of just turning it on and off. \u00a0You can hit different pitches on the buzzer. \u00a0Probably best of all you can send you servo motor to variable positions. \u00a0But you are limited to some degree by the fact that the 5V and 20milliamps coming out of the microcontroller pin is too little to be very bright, make much noise or move something big. \u00a0For that you would have add an intermediary \u00a0like a transistor to boost the power. \u00a0In the meantime there is plenty of fun you can have with these devices.   PWM   Your micronconroller is really only capable of on or off, so it fakes an analog circuit with with a technique called PWM or Pulse Width Modulation. \u00a0Basically it turns the pin on and off really fast. \u00a0When it leaves the pin on for longer than off, it has the feeling of being brighter. \u00a0Look at the two graphs below. \u00a0As you can imagine an LED attached to a pin with wider pulses, that is the pulses left on for longer will look brighter than the LED with the narrower pulses. \u00a0In truth the LED is really only on or off but your persistence of vision makes it look dimmer or brighter.\u00a0Even the longer pulses are on the order of microseconds so we don&#8217;t see the flicker.       Analog Out LED Circuit   \u00a0or\u00a0   You could also just use the old digital output circuit from last week and it would or okay but the one with capacitor is better (see below). \u00a0Make sure you connect to one of the pins marked for \u00a0PWM pins on your micro controller (look for a &#8220;~&#8221; next to the pins on a uno). \u00a0The advantage of these pins is the microcontroller will keep sending out that pattern of pulses in the background even when it moved on to another line of code that does something else.   Capacitors (optional read)      To help hide the flicker further this you will see a capacitor in the circuit. \u00a0This is the last of the major electronic components, resistors, diodes and capacitors. \u00a0A capacitor acts as a savings bank storing up energy when time are good and current is flowing. \u00a0When electricity stops flowing it discharges the stored energy filling in the blanks. \u00a0In this way it acts as a smoothing filter. \u00a0\u00a0 \u00a0This\u00a0If you\u2019re dimming an LED, start with a 10\u00b5f capacitor and a 220-ohm resistor, and experiment with different values from there to see what works best. \u00a0Some capacitors are polarized (it matter which leg is which). \u00a0You should see a minus sign on the casing of capacitor to indicate the polarity. \u00a0y.   Analog Output of Tones   If you connect a piezo buzzer to your circuit you can make some noise (you might want to do make sure you are alone because it is not av very pleasing sound). \u00a0The circuit is very easy, just one pin to ground and the other connected to an Arduino pin. \u00a0You will hear a click on and off if you try digitalWrite. \u00a0AnalogWrite will create a tone because the quick pulses will start some vibration but varying it will not be very satisfying. \u00a0If \u00a0you look at those graphs above they might look roughly like sound waves but if you look carefully even though they have different widths, they all start at the same intervals. \u00a0The interval between the waves determines how frequently they come along thus the frequency or pitch of the sound. \u00a0If you want to change the pitch of the sound you have take either take finer control by turning \u00a0on and off the wave for\u00a0 precise periods of microseconds\u00a0 or better yet use the tone command .                                           void setup() {    }    void loop() {   // turn off tone function for pin 9:   noTone(9);      // play a note on pin 9 for 200 ms:   tone(9, 440, 200);   delay(200);     // turn off tone function for pin 9:   noTone(9);   // play a note on pin 9 for 500 ms:   tone(9, 494, 500);   delay(500);     // turn off tone function for pin 9:   noTone(9);    // play a note on pin 9 for 500 ms:   tone(9, 523, 300);   delay(300);  }                                     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23                 void  setup ( )  {  }  void  loop ( )  {  // turn off tone function for pin 9:  noTone ( 9 ) ;      // play a note on pin 9 for 200 ms:  tone ( 9 ,  440 ,  200 ) ;  delay ( 200 ) ;   // turn off tone function for pin 9:  noTone ( 9 ) ;  // play a note on pin 9 for 500 ms:  tone ( 9 ,  494 ,  500 ) ;  delay ( 500 ) ;   // turn off tone function for pin 9:  noTone ( 9 ) ;   // play a note on pin 9 for 500 ms:  tone ( 9 ,  523 ,  300 ) ;  delay ( 300 ) ; }                                  Analog Output with Servo Motors   For really big fun you should play with servo motors. \u00a0With most motors you give them power and they spin. \u00a0Servo motors are different. \u00a0You give the a pulse of a particular duration or &#8220;width&#8221; and they turn to a corresponding angle. \u00a0For instance you give them a short pulse and they turn to zero degrees and you give them the longest pulse and they turn to 180 degrees (they usually can&#8217;t go all the way around).    Visit Liz Arum&#8217;s Page on This   Servo Connection   Servos usually come with three wires, black for ground, red for 5 V, and then another color the &#8220;signal&#8221; wire that you send a pulse to. \u00a0The end of the wire of a servo is typically a header with three holes which is too much like the holes in your breadboard to fit together. \u00a0If you can get your hands on some header posts it works nicely, otherwise stick some jumper wires in there.   \u00a0   Servo Software   You can create the pulse manually by turning on and off a pin using digitalWrite with microsecond precision. \u00a0Otherwise you can use the the servo library to make it a little easier. \u00a0You will notice in this code that there is an include statement at the top the refers to a library. \u00a0A library is an add on piece of code that is not part of the core processing code. \u00a0Luckily for you this library comes with the standard download of the Arduino environment so you don&#8217;t have to do anything except mention at the top that you intend to use it by saying #include &lt;Servo.h&gt; \u00a0.   Hard Way   digitalWrite(motoPin,HIGH);  delayMicroseconds(1850);  digitalWrite(motoPin,LOW);  delayMicroseconds(1850);   Easier Way Using Servo library                                           #include &lt;Servo.h&gt;  // include the servo library    Servo servoMotor;  // creates an instance of the servo object to control a servo    void setup() {   Serial.begin(9600);  // initialize serial communications   servoMotor.attach(2); // attaches the servo on pin 2 to the servo object  }    void loop()  {   int analogValue = analogRead(A0); // read the analog input   //Serial.println(analogValue);  // print it     // if your sensor's range is less than 0 to 1023, you'll need to   // modify the map() function to use the values you discovered:   int servoAngle = map(analogValue, 730, 980, 0, 179);   Serial.println(servoAngle);     // move the servo using the angle from the sensor:   servoMotor.write(servoAngle);  }                                     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22                 #include &lt;Servo.h&gt;  // include the servo library  Servo servoMotor ;   // creates an instance of the servo object to control a servo  void  setup ( )  {  Serial . begin ( 9600 ) ;   // initialize serial communications  servoMotor . attach ( 2 ) ;  // attaches the servo on pin 2 to the servo object }  void  loop ( ) {  int  analogValue  =  analogRead ( A0 ) ;  // read the analog input  //Serial.println(analogValue);  // print it   // if your sensor's range is less than 0 to 1023, you'll need to  // modify the map() function to use the values you discovered:  int  servoAngle  =  map ( analogValue ,  730 ,  980 ,  0 ,  179 ) ;  Serial . println ( servoAngle ) ;   // move the servo using the angle from the sensor:  servoMotor . write ( servoAngle ) ; }                                  You will also see a new function called map in this code. \u00a0Because the numbers we are getting in from some random analog sensor are unlikely to the exact numbers that some random servo want, you will have to do a like math to massage them. \u00a0Map does this for you. \u00a0You give it the number you want to convert in a variable, the range from the input, and the range for the output and it will return a number in the output range that is proportionate to the input number in the input range.   \u00a0You Don&#8217;t Really Need to Read Further   Analog Ouput Amplified with a Transitor   To power bigger motors or speakers or lights you will need and intermediary like a transistor. \u00a0http://itp.nyu.edu/physcomp/Tutorials/HighCurrentLoads                                                                                             Leave a Reply Cancel Reply            You must be logged in to post a comment.                                                       &copy; 2015 ICM &mdash; All Rights Reserved."}, {"content": "Analog Input | ITP Physical Computing                                                          ITP Physical Computing             Search                  Primary Menu       Skip to content       Syllabus Phys-comp List Topics What Is Physical Computing? Electronics Electricity: the Basics Transistors, Relays, and Controlling High-Current Loads Understanding DC Power Supplies  Microcontrollers Microcontrollers: The Basics Digital Input &#038; Output Analog Input Analog Output  Programming Programming Terms and Programming Environments Variables  Sensors: the Basics Serial Communication Asynchronous Serial Communication: The Basics Interpreting Serial Data Synchronous Serial Communication: The Basics  DC Motors DC Motors: The Basics Controlling Stepper Motors  Videos Videos: Electricity Videos: Tools Videos: Schematic Diagrams Videos: Sensors Videos: Digital and Analog Input and Output Videos: Serial Communication Videos: Relays, Transistors, and Motors Videos: Prototyping Methods and Tips  Labs Labs: Electronics Lab: Components Lab: Setting Up A Breadboard Lab: Switches Lab: Soldering Lab: Electronics  Labs: Arduino Digital and Analog Lab: Digital Input and Output with an Arduino Lab: Analog In with an Arduino Lab: Servo Motor Control with an Arduino Lab: Tone Output Using An Arduino Lab: Sensor Change Detection  Labs: Serial Communication Lab: Serial Output from an Arduino Lab: Two-way (Duplex) Serial Communication using an Arduino Lab: MIDI Output using an Arduino Lab: Arduino to DAW Lab: Serial Communication with Node.js Lab: SPI Communication With A Digital Potentiometer Lab: I2C Communication With An Infrared Temperature Sensor  Labs: Motors and Transistors Lab: Using a Transistor to Control a High Current Load Lab: Using a Transistor to Control High Current Loads with an Arduino Lab: DC Motor Control Using an H-Bridge Lab: Controlling a Stepper Motor With an H-Bridge  Labs: Mouse Control Lab: Mouse Control Lab: Mouse Control With Pushbuttons Lab: Mouse Control With Joystick  Resources Books GitHub Repository Parts Needed for Physical Computing Additional Useful Parts and Tools Other Useful Sites Suppliers Checkout Components at ITP LittleBits Resources  Sections Tom Igoe Class Oct 1 Afternoon  Benedetta Piantella MONDAY WEDNESDAY  Jeff Feddersen Arlene Ducao                                        Search for:                                                            Analog Input       Last edited 21 Aug 2014\u00a0by Tom Igoe.\u00a0   Introduction   This is an introduction to basic analog\u00a0input on a microcontroller. In order to get the most out of it, you should know something about\u00a0 electrical circuits ,\u00a0 what a microcontroller is \u00a0and what it can do, and digital input and output on a microcontroller .   Analog Input   While a digital input to a microcontroller can tell you about discrete changes in the physical world, such as whether the cat is on the mat, or the cat is off the mat, there are times when this is not enough. Sometimes you\u00a0want to know how fat the cat on the mat is. In order to know this, you&#8217;d\u00a0need to be able to measure the force the cat exerts on the mat as a variable quantity. When you\u00a0want to measure variably changing conditions like this, you need analog inputs. An analog input to a microcontroller is an\u00a0input that can read a variable voltage, typically from 0 volts to the maximum voltage that powers the microcontroller itself.   Many transducers are available to convert various changing conditions to changing electrical quantities. There are photocells that convert the amount of light falling on them to a varying resistance; flex sensors that change resistance as they are bent; Force-sensitive resistors (FSRs) that change resistance based on a changing force applied to the surface of the sensor; thermistors that change resistance in response to changing heat; and many more.   In order to read these changing resistances, you put them in a circuit and pass a current through them, so that you can see the changing voltage that results. There are a few variations on this circuit. The simplest is called a\u00a0 voltage divider . Because the two resistors are in series\u00a0voltage at the input to the microcontroller is proportional to the ratio of the resistors. If they are equal, then the input voltage is half the total voltage. So in the circuit below. if the variable resistor changes (for example, if it&#8217;s a flex sensor being bent), then the voltage at the input changes. \u00a0The fixed resistor&#8217;s value is generally chosen to complement the variable resistor&#8217;s range. For example, if you have a variable resistor that&#8217;s 10-20 kilohms, you might choose a 10 kilohm fixed resistor.     In the diagram below, you use a potentiometer,\u00a0 which is a\u00a0variable resistor with three connections. The center of the potentiometer, called the wiper, \u00a0is connected to the microcontroller. The other two sides are attached to power and ground. The wiper can move from one end of the resistor to the other. In effect, it divides the resistor into two resistors and measures the resistance at the point where they meet, just like a voltage divider.      Since a microcontroller&#8217;s inputs can read only two values (typically 0 volts or 5 volts), an analog input pin\u00a0needs an extra component to read this changing, or analog voltage, and convert it to a digital form. An analog-to-digital converter (ADC) is a device that does this. It reads a changing input voltage and converts it to a binary value, which a microcontroller can then store in memory.   ADCs are a common tool, and many microcontrollers have ADCs built in to them. The Arduino\u00a0has an\u00a0ADC built into it, attached to the analog input pins.   The ADC in the Arduino can read the input voltage at a resolution of 10 bits. That&#8217;s a range of 1024 points. If the input voltage range is 0 to 5 volts, that means that the smallest change it can read is 5/1024, or 0.048 Volts. When you take a reading with the ADC using the analogRead() command, the microcontroller stores the result in\u00a0memory. It takes an int type variable to store this, because a byte is not big enough. A byte\u00a0can hold only 8 bits, or a range from 0 to 255.   The resolution of an ADC changes from one model\u00a0to another. However, most microcontrollers with ADCs on board typically have 10-bit resolution.   The command in Arduino\u00a0is the analogRead() command, and it looks like this:     sensorReading = analogRead(pin);       Pin is the analog input pin you are using;   sensorReading \u00a0is an integer variable containing the result from the ADC.     The number produced in sensorReading\u00a0is will be between 0 and 1023. Its maximum may be less, depending on the\u00a0circuit you use. a potentiometer will give the full range, but a voltage divider where one of the resistors is fixed will not.   Decoupling Analog Inputs   If you find the readings from your analog inputs are inconsistent (for example, you see changes on one channel when the sensor on a different channel is the one sensing action), it helps to decouple your input circuit. Decoupling means smoothing out the dips and spikes going into the circuit from the rest of your microcontroller circuit. To do this, place a small capacitor (0.1 microfarad is good)\u00a0between\u00a0voltage and\u00a0ground as close to where the analog input connects to voltage, like so:          A capacitor used this way is referred to as a decoupling capacitor. You&#8217;ll see them a lot in electronic circuits. Think of them as tiny surge protectors.   The analog inputs on an Arduino (and in fact, on most microcontrollers), are all connected to the same ADC circuit, so when the microcontroller has to switch the ADC&#8217;s input from one pin to another when you try to read two pins one after another. If you read them too fast, you can get unstable readings.\u00a0You can also get more reliable readings by introducing a small delay after you take an analog reading. This allows the ADC time to stabilize before you take your next reading.   Here&#8217;s an example of how to read three analog inputs with minimal delay and maximum stability:      sensorOne = analogRead(A0);   delay(1);   sensorTwo = analogRead(A1);   delay(1);   sensorOne = analogRead(A2);   delay(1);     Analog and digital inputs are the two simplest ways that a microcontroller reads changing sensor voltage inputs.\u00a0Once you&#8217;ve understood these two, you&#8217;re ready to use a variety of sensors.                                                 Proudly powered by WordPress"}]}]